<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Java性能监控与故障处理分析工具（Heap memory和Native memory） - 空歌白石的个人博客 - 基于Hugo构建</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="空歌白石" /><meta name="description" content="前言 在实际的工作中会不断的遇到各种线上问题，包括但不限于内存溢出、服务响应时间上升、线程block等各种情况，这时候就需要性能监控以及故障处理工具来分析和定位问题，google后发现并没有一篇分类清晰、实用的文章能够概括以上对于工具的需求，因此，决定整理一下相关的内容，以供大家学习参考。
本文意在介绍了有哪些常用的分析工具，以方便大家能够快速的分析定位问题。@空歌白石
文章的整个编写思路可以通过如下思维导图所示：
这里有几点需要说明：
 JDK原生工具特别是jmc以及arthas是在线实时分析工具，mat是离线分析工具，jProfiler也可以支持离线和实时分析。 以上工具都是很大篇幅是针对堆内内存进行分析，对于堆外内存的问题分析能力十分有限甚至可以说没有。 如果如果确定是堆外内存问题，一般堆外内存溢出排查可结合 gperftools 与 btrace 排查。 " /><meta name="keywords" content="Hugo, Java, 技术" />






<meta name="generator" content="Hugo 0.99.1 with theme even" />


<link rel="canonical" href="https://liubr1491.github.io/post/java%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7heap-memory%E5%92%8Cnative-memory/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Java性能监控与故障处理分析工具（Heap memory和Native memory）" />
<meta property="og:description" content="前言
在实际的工作中会不断的遇到各种线上问题，包括但不限于内存溢出、服务响应时间上升、线程block等各种情况，这时候就需要性能监控以及故障处理工具来分析和定位问题，google后发现并没有一篇分类清晰、实用的文章能够概括以上对于工具的需求，因此，决定整理一下相关的内容，以供大家学习参考。
本文意在介绍了有哪些常用的分析工具，以方便大家能够快速的分析定位问题。@空歌白石
文章的整个编写思路可以通过如下思维导图所示：

这里有几点需要说明：

JDK原生工具特别是jmc以及arthas是在线实时分析工具，mat是离线分析工具，jProfiler也可以支持离线和实时分析。
以上工具都是很大篇幅是针对堆内内存进行分析，对于堆外内存的问题分析能力十分有限甚至可以说没有。
如果如果确定是堆外内存问题，一般堆外内存溢出排查可结合 gperftools 与 btrace 排查。
" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://liubr1491.github.io/post/java%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7heap-memory%E5%92%8Cnative-memory/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-08-06T10:04:45+08:00" />
<meta property="article:modified_time" content="2022-08-06T10:04:45+08:00" />

<meta itemprop="name" content="Java性能监控与故障处理分析工具（Heap memory和Native memory）">
<meta itemprop="description" content="前言
在实际的工作中会不断的遇到各种线上问题，包括但不限于内存溢出、服务响应时间上升、线程block等各种情况，这时候就需要性能监控以及故障处理工具来分析和定位问题，google后发现并没有一篇分类清晰、实用的文章能够概括以上对于工具的需求，因此，决定整理一下相关的内容，以供大家学习参考。
本文意在介绍了有哪些常用的分析工具，以方便大家能够快速的分析定位问题。@空歌白石
文章的整个编写思路可以通过如下思维导图所示：

这里有几点需要说明：

JDK原生工具特别是jmc以及arthas是在线实时分析工具，mat是离线分析工具，jProfiler也可以支持离线和实时分析。
以上工具都是很大篇幅是针对堆内内存进行分析，对于堆外内存的问题分析能力十分有限甚至可以说没有。
如果如果确定是堆外内存问题，一般堆外内存溢出排查可结合 gperftools 与 btrace 排查。
"><meta itemprop="datePublished" content="2022-08-06T10:04:45+08:00" />
<meta itemprop="dateModified" content="2022-08-06T10:04:45+08:00" />
<meta itemprop="wordCount" content="21195">
<meta itemprop="keywords" content="开发工具,JVM,性能分析," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Java性能监控与故障处理分析工具（Heap memory和Native memory）"/>
<meta name="twitter:description" content="前言
在实际的工作中会不断的遇到各种线上问题，包括但不限于内存溢出、服务响应时间上升、线程block等各种情况，这时候就需要性能监控以及故障处理工具来分析和定位问题，google后发现并没有一篇分类清晰、实用的文章能够概括以上对于工具的需求，因此，决定整理一下相关的内容，以供大家学习参考。
本文意在介绍了有哪些常用的分析工具，以方便大家能够快速的分析定位问题。@空歌白石
文章的整个编写思路可以通过如下思维导图所示：

这里有几点需要说明：

JDK原生工具特别是jmc以及arthas是在线实时分析工具，mat是离线分析工具，jProfiler也可以支持离线和实时分析。
以上工具都是很大篇幅是针对堆内内存进行分析，对于堆外内存的问题分析能力十分有限甚至可以说没有。
如果如果确定是堆外内存问题，一般堆外内存溢出排查可结合 gperftools 与 btrace 排查。
"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">空歌白石</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">首页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">空歌白石</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">首页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Java性能监控与故障处理分析工具（Heap memory和Native memory）</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-08-06 </span>
        <div class="post-category">
            <a href="/categories/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"> 性能分析 </a>
            </div>
          <span class="more-meta"> 约 21195 字 </span>
          <span class="more-meta"> 预计阅读 43 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#前言">前言</a></li>
    <li><a href="#java-process-memory">Java process memory</a>
      <ul>
        <li><a href="#native-memory">Native Memory</a></li>
        <li><a href="#direct-memory">Direct Memory</a></li>
        <li><a href="#oom">OOM</a></li>
        <li><a href="#堆外内存的优点">堆外内存的优点</a></li>
      </ul>
    </li>
    <li><a href="#jdk原生工具">JDK原生工具</a>
      <ul>
        <li><a href="#troubleshooting排障工具">Troubleshooting（排障工具）</a>
          <ul>
            <li><a href="#jinfo">jinfo</a></li>
            <li><a href="#jmap">jmap</a></li>
            <li><a href="#jhat">jhat</a></li>
            <li><a href="#jstack">jstack</a></li>
            <li><a href="#jcmd">jcmd</a></li>
            <li><a href="#jsadebugd">jsadebugd</a></li>
          </ul>
        </li>
        <li><a href="#monitor-the-jvm">Monitor the JVM</a>
          <ul>
            <li><a href="#jps">jps</a></li>
            <li><a href="#jstat">jstat</a></li>
            <li><a href="#jmc">jmc</a></li>
            <li><a href="#jstatd">jstatd</a></li>
          </ul>
        </li>
        <li><a href="#monitor-java-applications">Monitor Java Applications</a>
          <ul>
            <li><a href="#jconsole">jconsole</a></li>
            <li><a href="#visualvmall-in-one-java-troubleshooting-tool">VisualVM（All-in-One Java Troubleshooting Tool）</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#arthas">arthas</a>
      <ul>
        <li><a href="#start-arthas">start arthas</a></li>
        <li><a href="#help">help</a></li>
        <li><a href="#jvm相关">jvm相关</a>
          <ul>
            <li><a href="#dashboard">dashboard</a></li>
            <li><a href="#jvm">jvm</a></li>
            <li><a href="#thread-1">thread</a></li>
          </ul>
        </li>
        <li><a href="#classclassloader相关">class/classloader相关</a>
          <ul>
            <li><a href="#sc--sm">sc &amp; sm</a></li>
            <li><a href="#jad">jad</a></li>
            <li><a href="#redefine">redefine</a></li>
          </ul>
        </li>
        <li><a href="#monitorwatchtrace-相关">monitor/watch/trace 相关</a>
          <ul>
            <li><a href="#watch">watch</a></li>
            <li><a href="#trace">trace</a></li>
            <li><a href="#stack">stack</a></li>
            <li><a href="#tt">tt</a></li>
          </ul>
        </li>
        <li><a href="#profiler火焰图">profiler/火焰图</a></li>
      </ul>
    </li>
    <li><a href="#mat">mat</a>
      <ul>
        <li><a href="#应用场景">应用场景</a></li>
        <li><a href="#使用介绍">使用介绍</a>
          <ul>
            <li><a href="#overview-1">Overview</a></li>
            <li><a href="#object-view">Object View</a></li>
            <li><a href="#actions">Actions</a></li>
            <li><a href="#reports">Reports</a></li>
          </ul>
        </li>
        <li><a href="#使用技巧">使用技巧</a>
          <ul>
            <li><a href="#索引构建">索引构建</a></li>
            <li><a href="#条件搜索">条件搜索</a></li>
            <li><a href="#references">References</a></li>
            <li><a href="#path-to-gc-roots">Path To GC Roots</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#jprofiler">JProfiler</a></li>
    <li><a href="#native-memory-analysis">Native memory analysis</a>
      <ul>
        <li><a href="#pmap">pmap</a></li>
        <li><a href="#gperftools">gperftools</a></li>
        <li><a href="#gdb">gdb</a></li>
        <li><a href="#nmt">NMT</a></li>
      </ul>
    </li>
    <li><a href="#总结">总结</a></li>
    <li><a href="#参考文献">参考文献</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h1 id="前言">前言</h1>
<p>在实际的工作中会不断的遇到各种线上问题，包括但不限于内存溢出、服务响应时间上升、线程block等各种情况，这时候就需要性能监控以及故障处理工具来分析和定位问题，google后发现并没有一篇分类清晰、实用的文章能够概括以上对于工具的需求，因此，决定整理一下相关的内容，以供大家学习参考。</p>
<p>本文意在介绍了有哪些常用的分析工具，以方便大家能够快速的分析定位问题。<a href="https://juejin.cn/user/1310273590294168">@空歌白石</a></p>
<p>文章的整个编写思路可以通过如下思维导图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0b73614005c41fbae2846fc53952e57~tplv-k3u1fbpfcp-watermark.image?" alt="java-profile-xmind.png"></p>
<p>这里有几点需要说明：</p>
<ol>
<li>JDK原生工具特别是<code>jmc</code>以及<code>arthas</code>是在线实时分析工具，<code>mat</code>是离线分析工具，<code>jProfiler</code>也可以支持离线和实时分析。</li>
<li>以上工具都是很大篇幅是针对堆内内存进行分析，对于堆外内存的问题分析能力十分有限甚至可以说没有。</li>
<li>如果如果确定是堆外内存问题，一般堆外内存溢出排查可结合 <code>gperftools</code> 与 <code>btrace</code> 排查。</li>
</ol>
<h1 id="java-process-memory">Java process memory</h1>
<p>在介绍工具前，先来了解下Java进程内存的分类：</p>
<ol>
<li>Heap memory（堆内存）
<ul>
<li>供Java应用程序使用。</li>
<li>Heap memory 存在于 JVM 进程中，并用于保存 Java 对象，有 JVM 垃圾收集器维护的内存。</li>
<li>Heap Memory 及其内部各组成的大小可以通过JVM的一系列命令行参数来控制，也就是一般意义上提到的JVM参数（不同的GC参数也会不同）。</li>
</ul>
</li>
<li>Native memory/Off-heap（堆外内存）
<ul>
<li>供JVM自身进程使用。</li>
<li>Native memory 是在进程地址空间内分配的内存，由操作系统负责。由于不在堆内，因此不会被 Java 垃圾收集器释放和管理。</li>
<li>Native Memory 没有相应的参数来控制大小，其大小依赖于操作系统进程的最大值（对于32位系统就是3~4G，各种系统的实现并不一样），以及生成的Java字节码大小、创建的线程数量、维持java对象的状态信息大小（用于GC）以及一些第三方的包，比如JDBC驱动使用的native内存。</li>
</ul>
</li>
</ol>
<p>除了以上来两种内存外，还经常会提到Direct memory，Direct memory类似于Native memory，会使用共享硬件内的底层缓冲区。例如，网络IO的缓冲区，设置<code>Direct memory</code>是减少相同字节在内存中被复制的次数。</p>
<h2 id="native-memory">Native Memory</h2>
<p>为什么会有Native Memory？以下是Native Memory的一些职责。</p>
<ul>
<li>管理java heap的状态数据（用于GC）;</li>
<li>JNI调用，也就是Native Stack;</li>
<li>JIT（即使编译器）编译时使用Native Memory，并且JIT的输入（Java字节码）和输出（可执行代码）也都是保存在Native Memory；</li>
<li>NIO direct buffer。对于IBM JVM和Hotspot，都可以通过-XX:MaxDirectMemorySize来设置nio直接缓冲区的最大值。默认是64M。超过这个时，会按照32M自动增大。</li>
<li>对于IBM的JVM某些版本实现，类加载器和类信息都是保存在Native Memory中的。</li>
</ul>
<h2 id="direct-memory">Direct Memory</h2>
<p><code>Direct Memory</code>在Java中都是由<code>DirectBuffer</code>来负责维护的，DirectBuffer访问更快，避免了从HeapBuffer还需要从java堆拷贝到本地堆，操作系统直接访问的是DirectBuffer。DirectBuffer对象的数据实际是保存在native heap中，但是引用保存在HeapBuffer中。这也就是我们经常会遇到的一个问题，堆内内存很稳定，但是堆外的内存一直释放不掉，需要看下保存在<code>HeapBuffer</code>的引用是否已经被去掉了。</p>
<p>另外，DirectBuffer的引用是直接分配在堆得Old区的，因此其回收时机是在FullGC时。因此，需要避免频繁的分配DirectBuffer，这样很容易导致Native Memory溢出。</p>
<ul>
<li><code>Direct Memory</code>并非 JVMS 定义的标准 Java 运行时内存。</li>
<li>JDK1.4 加入了新的 NIO 机制，目的是防止 Java 堆 和 Native 堆之间往复的数据复制带来的性能损耗，此后 NIO 可以使用 Native 的方式直接在 Native 堆分配内存。</li>
<li><code>Direct Memory</code>区域是全局共享的内存区域。</li>
<li><code>Direct Memory</code>区域可以进行自动内存管理(GC)，但机制并不完善。</li>
<li>本机的 Native 堆(直接内存) 不受 JVM 堆内存大小限制。</li>
<li>可能出现 OutOfMemoryError 异常。</li>
</ul>
<h2 id="oom">OOM</h2>
<p>Java进程内存由<code>Heap memory</code>和<code>Native memory</code>组成，也就是堆内内存和堆外内存。两块内存空间都有可能发生OOM。因此在遇到OOM的异常时，首先要区分是哪块内存空间发生了OOM，然后在针对性的定位。但不论怎样<code>Native Memory</code>发生OOM本质上就是因为耗尽了进程地址空间。</p>
<p>如果发现进程内存过高，可能需要注意下程序是否存在堆外内存泄漏问题，java进程出现的堆外内存泄漏常见有如下几个方面：</p>
<ul>
<li>JNI</li>
<li>NIO directbuffer泄漏
<ul>
<li>网络编程中程序中，<code>NIO directbuffer</code>有监控工具可以查看，<code>directbuffer</code>使用量、并且可以设置最大直接内存buffer。</li>
</ul>
</li>
<li>gzip</li>
</ul>
<p>下文中讲到的<code>JDK原生工具</code>、<code>arthas</code>、<code>mat</code>、<code>JProfiler</code>都是针对<code>Heap memory</code>的，而针对<code>Native memory</code>请查看<code>Native memory analysis</code>小节。</p>
<h2 id="堆外内存的优点">堆外内存的优点</h2>
<p>使用堆外内存有很多优点，但是对于开发人员的要求更高，因为没有JVM的GC来负责，对于内存的控制需要更加精确和小心，否则很容易就会造成堆内和堆外内存的OOM，并且排查起来也会很困难。</p>
<ul>
<li>减少了垃圾回收
<ul>
<li>因为垃圾回收会暂停其他的工作。</li>
</ul>
</li>
<li>加快了复制的速度
<ul>
<li>堆内在flush到远程时，会先复制到直接内存（非堆内存），然后在发送；而堆外内存相当于省略掉了这个工作。</li>
</ul>
</li>
</ul>
<h1 id="jdk原生工具">JDK原生工具</h1>
<p>JDK本身提供了丰富的监控工具，拥有强大的功能。在监控方面包含两大类：一类是监控应用的，一类是监控JVM的，在故障排查中也有诸多的工具可以用。</p>
<p>官方文档：https://docs.oracle.com/javase/8/docs/technotes/tools/unix/toc.html</p>
<p>本文使用的Jdk版本：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[user@server-name ~]$ java -version
</span></span><span class="line"><span class="cl">openjdk version &#34;11.0.14.1&#34; 2022-02-08
</span></span><span class="line"><span class="cl">OpenJDK Runtime Environment Temurin-11.0.14.1+1 (build 11.0.14.1+1)
</span></span><span class="line"><span class="cl">OpenJDK 64-Bit Server VM Temurin-11.0.14.1+1 (build 11.0.14.1+1, mixed mode)
</span></span></code></pre></td></tr></table>
</div>
</div><p>jdk/bin目录下包含了全部的tools集合。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10a31870b7c74dcebe3bbb9714e9fecd~tplv-k3u1fbpfcp-watermark.image?" alt="jdk-bin.png"></p>
<h2 id="troubleshooting排障工具">Troubleshooting（排障工具）</h2>
<h3 id="jinfo">jinfo</h3>
<p>jinfo: Java配置信息工具，<code>Configuration Info for Java</code>，显示虚拟机配置信息，可以实时地查看和调整虚拟机各项参数。</p>
<ul>
<li>使用jps命令的-v参数可以查看虚拟机启动时显式指定的参数列表，但如果想知道未被显式指定的参数的系统默认值，除了去找资料外，就只能使用jinfo的-flag选项进行查询了(如果只限于 JDK 1.6或以上版本的话，使用java -XX : +PrintFlagsFinal查看参数默认值也是一个很好的选择 )；</li>
<li>jinfo还可以使用-sysprops选项把虚拟机进程的System.getProperties() 的内容打印出来。</li>
</ul>
<p><code>jinfo</code>在JDK 1.5时期已经随着Linux版的JDK发布，当时只提供了信息查询的功能，JDK1.6之后，jinfo在Windows和Linux平台都有提供，并且加入了运行期修改参数的能力，可以使用<code>-flag[+|-jname</code>或者<code>-flag name=value</code>修改一部分运行期可写的虚拟机参数值。JDK 1.6中，jinfo对于Windows平台功能仍然有较大限制，只提供了最基本的-flag选项。</p>
<p><strong>jinfo命令格式</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">Usage:
</span></span><span class="line"><span class="cl">    jinfo &lt;option&gt; &lt;pid&gt;
</span></span><span class="line"><span class="cl">       <span class="o">(</span>to connect to a running process<span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">where &lt;option&gt; is one of:
</span></span><span class="line"><span class="cl">    -flag &lt;name&gt;         to print the value of the named VM flag
</span></span><span class="line"><span class="cl">    -flag <span class="o">[</span>+<span class="p">|</span>-<span class="o">]</span>&lt;name&gt;    to <span class="nb">enable</span> or disable the named VM flag
</span></span><span class="line"><span class="cl">    -flag &lt;name&gt;<span class="o">=</span>&lt;value&gt; to <span class="nb">set</span> the named VM flag to the given value
</span></span><span class="line"><span class="cl">    -flags               to print VM flags
</span></span><span class="line"><span class="cl">    -sysprops            to print Java system properties
</span></span><span class="line"><span class="cl">    &lt;no option&gt;          to print both VM flags and system properties
</span></span><span class="line"><span class="cl">    -? <span class="p">|</span> -h <span class="p">|</span> --help <span class="p">|</span> -help to print this <span class="nb">help</span> message
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">jinfo <span class="o">[</span>option<span class="o">]</span> pid
</span></span></code></pre></td></tr></table>
</div>
</div><p>使用<code>ps -ef | grep 'java'</code>查看当前运行应用的PID。执行命令<code>jinfo [option] pid</code>后，可以看到当前JVM的运行参数，主要包含四部分：</p>
<ol>
<li>Java System Properties
<ul>
<li>使用<code>jinfo -sysprops pid</code>命令单独查看</li>
</ul>
</li>
<li>VM Flags
<ul>
<li>使用<code>jinfo -flags pid</code>命令单独查看</li>
</ul>
</li>
<li>VM Arguments</li>
<li>Launcher Type</li>
</ol>
<p>在最后的参数会有<code>Launcher Type: SUN_STANDARD</code>说明当前标准的Launcher。</p>
<p>查看java进程的更为丰富的指令<code>ps -ef | grep java | grep -v grep | awk '{printf &quot;%d\t%s&quot;,$2,$8}'</code>。</p>
<h3 id="jmap">jmap</h3>
<p><code>jmap</code>: Java内存映像工具，<code>Memory Map for Java</code>，生成虚拟机的内存转储快照（一般称为heapdump或dump文件）</p>
<p>如果不使用<code>jmap</code>命令，要想获取Java堆转储快照，还有一些比较<em>暴力</em>的手段：</p>
<ul>
<li>譬如<code>-XX:+HeapDumpOnOutOfMemoryError</code>参数，可以让虚拟机在OOM异常出现之后自动生成dump文件
<ul>
<li>此方法在频繁发生OOM需要准确捕获当时现场的需求场景下十分有效。但是并不推荐生产的全部机器都配置，仅仅配置1-2台能够抓取dump即可</li>
<li>还需要注意一点是，由于某些情况下dump文件会很大，因此需要预留足够的磁盘空间。</li>
</ul>
</li>
<li>通过<code>-XX:+HeapDumpOnCtrlBreak</code>参数则可以使用[Ctrl]+[Break]键让虚拟机生成dump文件</li>
<li>又或者在Linux系统下通过<code>Kill -3</code>命令发送进程退出信号<em>吓唬</em>下虚拟机，也能拿到dump文件</li>
</ul>
<p><code>jmap</code>的作用并不仅仅是为了获取dump文件，它还可以查询<code>finalize</code>执行队列、Java堆和永久代的详细信息，如空间使用率、当前用的是哪种收集器等。</p>
<p>和<code>jinfo</code>命令一样，<code>jmap</code>有不少功能在Windows平台下都是受限的，除了生成dump文件的<code>-dump</code>选项和用于查看每个类的实例、空间占用统计的<code>-histo</code>选项在所有操作系统都提供之外，其余选项都只能在Linux/Solaris下使用。但是经过在本地测试，<code>jdk1.8</code>在Windows平台下支持的参数不仅仅是上面两个。</p>
<p><code>jmap</code>或<code>jmap -h</code>命令可以查看<code>jmap</code>的全部参数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Usage:
</span></span><span class="line"><span class="cl">    jmap -clstats &lt;pid&gt;
</span></span><span class="line"><span class="cl">        to connect to running process and print class loader statistics
</span></span><span class="line"><span class="cl">    jmap -finalizerinfo &lt;pid&gt;
</span></span><span class="line"><span class="cl">        to connect to running process and print information on objects awaiting finalization
</span></span><span class="line"><span class="cl">    jmap -histo[:live] &lt;pid&gt;
</span></span><span class="line"><span class="cl">        to connect to running process and print histogram of java object heap
</span></span><span class="line"><span class="cl">        if the &#34;live&#34; suboption is specified, only count live objects
</span></span><span class="line"><span class="cl">    jmap -dump:&lt;dump-options&gt; &lt;pid&gt;
</span></span><span class="line"><span class="cl">        to connect to running process and dump java heap
</span></span><span class="line"><span class="cl">    jmap -? -h --help
</span></span><span class="line"><span class="cl">        to print this help message
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    dump-options:
</span></span><span class="line"><span class="cl">      live         dump only live objects; if not specified,
</span></span><span class="line"><span class="cl">                   all objects in the heap are dumped.
</span></span><span class="line"><span class="cl">      format=b     binary format
</span></span><span class="line"><span class="cl">      file=&lt;file&gt;  dump heap to &lt;file&gt;
</span></span><span class="line"><span class="cl">      parallel=&lt;number&gt;  parallel threads number for heap iteration:
</span></span><span class="line"><span class="cl">                         parallel=0 default behavior, use predefined number of threads
</span></span><span class="line"><span class="cl">                         parallel=1 disable parallel heap iteration
</span></span><span class="line"><span class="cl">                         parallel=&lt;N&gt; use N threads for parallel heap iteration
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    Example: jmap -dump:live,format=b,file=heap.bin &lt;pid&gt;
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="jmap--dump">jmap -dump</h4>
<p><code>jmap –dump:[live, ]format=b, file=&lt;filename&gt;</code>，<code>-dump</code>参数应该是<code>jmap</code>命令最常用的部分，可以生成当前运行时的堆内存文件。</p>
<p>实际运行<code>jmap -dump:live,format=b,file=/opt/logs/dump.hprof 37</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[user@server-name ~]$ jmap -dump:live,format=b,file=/opt/logs/dump.hprof 37
</span></span><span class="line"><span class="cl">Dumping heap to /mnt/mesos/sandbox/dump.hprof ...
</span></span><span class="line"><span class="cl">Heap dump file created [191760650 bytes in 1.306 secs]
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到文件已经生成。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[user@server-name app]$ ls -lh | grep &#39;dump&#39;
</span></span><span class="line"><span class="cl">-rw------- 1 deploy deploy 183M Aug  4 15:20 dump.hprof
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="文件传输">文件传输</h5>
<p>接下来就是可以使用<code>sz dump.hprof</code>或者通过sftp可以将dump文件转移到其他可以分析dump的机器上进一步分析。</p>
<p>这里可能有个问题，如果dump文件较小使用<code>sz</code>命令还可以轻松处理，但是当dump有十几个GB甚至上百GB的时候会很难轻松传输。这个问题可以通过临时搭建一个httpServer来解决。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">sudo -u ${user} python -m SimpleHTTPServer 8989
</span></span></code></pre></td></tr></table>
</div>
</div><p>**注意:**上述指令需要到dump文件所在目录执行，8989可以替换为任意可用端口。</p>
<ul>
<li>如果使用<code>sz</code>可以轻松将文件传输到本地</li>
<li>如果使用HttpServer的话
<ul>
<li>对于Widnows系统，通过域名加端口，浏览器直接下载即可</li>
<li>对于Linux系统，可以使用<code>sudo wget http://ip:port/dump.hprof</code> 方式下载</li>
</ul>
</li>
</ul>
<h4 id="jmap--clstats">jmap -clstats</h4>
<p><code>jmap -clstats {pid}</code>查看当前class的统计情况。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[user@server-name ~]$ jmap -clstats 37
</span></span><span class="line"><span class="cl">Index Super InstBytes KlassBytes annotations    CpAll MethodCount Bytecodes MethodAll    ROAll    RWAll     Total ClassName
</span></span><span class="line"><span class="cl">    1    -1  68222800        504           0        0           0         0         0       24      688       712 [B
</span></span><span class="line"><span class="cl">    2    -1  11901560        504           0        0           0         0         0       24      688       712 [Ljava.lang.Object;
</span></span><span class="line"><span class="cl">    3    28  10398400        616         128    14272         109      4576     72768    18640    70528     89168 java.lang.String
</span></span><span class="line"><span class="cl">    4    -1   6449920        504           0        0           0         0         0       24      688       712 [C
</span></span><span class="line"><span class="cl">    5    28   5511744        592           0     1368           9       213      2776     1488     3656      5144 java.util.concurrent.Concurre                                ntHashMap$Node
</span></span><span class="line"><span class="cl">    6 15988   5055040       1112           0     6824          47      1117     27072     6480    29344     35824 java.lang.reflect.Method
</span></span><span class="line"><span class="cl">    7    28   4490304        584           0     1392           7       149      2280     1152     3496      4648 java.util.HashMap$Node
</span></span><span class="line"><span class="cl">    8    28   4306256        672           0    22120         139      5679     92112    24632    92272    116904 java.lang.Class
</span></span><span class="line"><span class="cl">    9    -1   3996512        504           0        0           0         0         0       32      688       720 [Ljava.util.HashMap$Node;
</span></span><span class="line"><span class="cl">   10     7   3574208        584           0      512           1        10       624      304     1720      2024 java.util.LinkedHashMap$Entry
</span></span><span class="line"><span class="cl">   11    -1   3218680        504           0        0           0         0         0       24      688       712 [J
</span></span><span class="line"><span class="cl">   12    -1   2375040        504           0        0           0         0         0       32      688       720 [Ljava.util.concurrent.Concur                                rentHashMap$Node;
</span></span><span class="line"><span class="cl">   13    -1   1419800        504           0        0           0         0         0       24      688       712 [I
</span></span><span class="line"><span class="cl">   14    19   1304952       1096           0     3816          26       879     12840     4608    13824     18432 java.util.LinkedHashMap
</span></span><span class="line"><span class="cl">   15    -1   1178632        504           0        0           0         0         0       56      688       744 [Ljava.lang.Class;
</span></span></code></pre></td></tr></table>
</div>
</div><p>一般情况下我们使用以下命令打印当前Class信息，并输出到指定的文件中。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">sudo -u ${loginUser} /usr/java/jdk11/bin/jmap -clstats ${pid} &gt; /tmp/jamp-class-state.txt
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>loginUser：用当前登录用户替换</li>
<li>pid：上文中获取的PID</li>
</ul>
<h4 id="jmap--finalizerinfo">jmap -finalizerinfo</h4>
<p><code>jmap -finalizerinfo {pid}</code>，查询<code>finalize</code>执行队列绝大部分情况，应该是如下信息。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">No instances waiting for finalization found
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="jmap--histo">jmap -histo</h4>
<p><code>jmap -histo {pid}</code>，可以查看具体class的实例数量以及所占用的堆大小。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"> num     #instances         #bytes  class name (module)
</span></span><span class="line"><span class="cl">-------------------------------------------------------
</span></span><span class="line"><span class="cl">   1:        341732       68106488  [B (java.base@11.0.14.1)
</span></span><span class="line"><span class="cl">   2:         38389       11894656  [Ljava.lang.Object; (java.base@11.0.14.1)
</span></span><span class="line"><span class="cl">   3:        326579       10450528  java.lang.String (java.base@11.0.14.1)
</span></span><span class="line"><span class="cl">   4:          2737        6501528  [C (java.base@11.0.14.1)
</span></span><span class="line"><span class="cl">   5:        114588        5500224  java.util.concurrent.ConcurrentHashMap$Node (java.base@11.0.14.1)
</span></span><span class="line"><span class="cl">   6:         31594        5055040  java.lang.reflect.Method (java.base@11.0.14.1)
</span></span><span class="line"><span class="cl">   7:         95935        4604880  java.util.HashMap$Node (java.base@11.0.14.1)
</span></span><span class="line"><span class="cl">   8:         22224        4312488  java.lang.Class (java.base@11.0.14.1)
</span></span><span class="line"><span class="cl">   9:         22770        4042288  [Ljava.util.HashMap$Node; (java.base@11.0.14.1)
</span></span><span class="line"><span class="cl">  10:         55175        3531200  java.util.LinkedHashMap$Entry (java.base@11.0.14.1)
</span></span><span class="line"><span class="cl">  11:          1889        3219520  [J (java.base@11.0.14.1)
</span></span><span class="line"><span class="cl">  12:          2979        2364200  [Ljava.util.concurrent.ConcurrentHashMap$Node; (java.base@11.0.14.1)
</span></span><span class="line"><span class="cl">  13:         18508        1420608  [I (java.base@11.0.14.1)
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以添加<code>grep</code>过滤结果，如<code>jmap -histo 37 | grep 'sun'</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">  33:          3251         390120  sun.util.calendar.Gregorian$Date (java.base@11.0.14.1)
</span></span><span class="line"><span class="cl">  45:          2555         224840  sun.util.calendar.ZoneInfo (java.base@11.0.14.1)
</span></span><span class="line"><span class="cl">  63:          4162         166480  sun.reflect.annotation.AnnotationInvocationHandler (java.base@11.0.14.1)
</span></span><span class="line"><span class="cl">  67:          3817         152680  sun.reflect.generics.tree.SimpleClassTypeSignature (java.base@11.0.14.1)
</span></span><span class="line"><span class="cl">  76:          1038         124560  sun.util.calendar.JulianCalendar$Date (java.base@11.0.14.1)
</span></span><span class="line"><span class="cl">  87:          3817         103720  [Lsun.reflect.generics.tree.TypeArgument; (java.base@11.0.14.1)
</span></span><span class="line"><span class="cl">  93:          1476          94464  sun.util.locale.LocaleObjectCache$CacheEntry (java.base@11.0.14.1)
</span></span><span class="line"><span class="cl">  99:          3676          88224  sun.reflect.generics.tree.ClassTypeSignature (java.base@11.0.14.1)
</span></span><span class="line"><span class="cl"> 111:          1543          74064  sun.security.util.ObjectIdentifier (java.base@11.0.14.1)
</span></span><span class="line"><span class="cl"> 127:           367          64592  sun.nio.ch.SocketChannelImpl (java.base@11.0.14.1)
</span></span><span class="line"><span class="cl"> 145:           796          57312  com.sun.beans.introspect.PropertyInfo (java.desktop@11.0.14.1)
</span></span><span class="line"><span class="cl"> 160:          1035          49680  sun.security.util.DerInputBuffer (java.base@11.0.14.1)
</span></span><span class="line"><span class="cl"> 166:          1165          46600  sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl (java.base@11.0.14.1)
</span></span><span class="line"><span class="cl"> 175:          1035          41400  sun.security.util.DerValue (java.base@11.0.14.1)
</span></span><span class="line"><span class="cl"> 176:           737          41272  sun.util.locale.BaseLocale (java.base@11.0.14.1)
</span></span><span class="line"><span class="cl"> 178:          1009          40360  sun.security.x509.RDN (java.base@11.0.14.1)
</span></span><span class="line"><span class="cl"> 181:           615          39360  sun.reflect.generics.repository.MethodRepository (java.base@11.0.14.1)
</span></span><span class="line"><span class="cl"> 191:          1138          36416  com.sun.beans.introspect.MethodInfo (java.desktop@11.0.14.1)
</span></span><span class="line"><span class="cl"> 193:          1307          36080  [Lsun.reflect.generics.tree.FieldTypeSignature; (java.base@11.0.14.1)
</span></span><span class="line"><span class="cl"> 203:          1088          34816  sun.reflect.generics.factory.CoreReflectionFactory (java.base@11.0.14.1)
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="jhat">jhat</h3>
<p><code>jhat</code>: 堆转储快照分析工具，<code>JVM Heap Analysis Tool</code>的缩写，用于分析heapdump文件，它会建立一个HTTP/HTML服务器，让用户可以在浏览器上查看分析结果。</p>
<p>使用命令<code>jhat dump.hprof</code>。</p>
<p>实际工作中，一般不会直接使用 jhat 命令来分析 dump 文件，主要原因：</p>
<ol>
<li>一般不会在生产环境直接分析 dump 文件，主要包括几方面原因：
<ul>
<li>分析工作一般比较耗时，而且消耗硬件资源，生产环境一般内存仅仅够程序正常运行使用，无法满足dump的分析需求</li>
<li>如果在其他机器上进行时则没必要受到命令行工具的限制</li>
</ul>
</li>
<li><code>jhat</code> 分析功能相对简陋，大部分情况下会使用后续介绍的<code>Java VisualVM</code>、<code>Eclipse Memory Analyzer (mat)</code>等更功能更加强大可视化工具分析。</li>
</ol>
<p>因此，这里只是了解有这个命令即可，无需过多关注。</p>
<h3 id="jstack">jstack</h3>
<p><code>jstack</code>: Java堆栈跟踪工具，<code>Stack Trace for Java</code>，生成虚拟机当前时刻的线程快照（一般称为 <code>threaddump</code> 或 <code>javacore</code> 文件）。</p>
<p><code>线程快照</code>就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成堆栈快照的主要目的是定位线程出现长时间停顿的原因，如线程死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的常见原因。</p>
<p><code>jstack</code>命令说明：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[user@server-name ~]$ jstack
</span></span><span class="line"><span class="cl">Usage:
</span></span><span class="line"><span class="cl">    jstack [-l][-e] &lt;pid&gt;
</span></span><span class="line"><span class="cl">        (to connect to running process)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Options:
</span></span><span class="line"><span class="cl">    -l  long listing. Prints additional information about locks
</span></span><span class="line"><span class="cl">    -e  extended listing. Prints additional information about threads
</span></span><span class="line"><span class="cl">    -? -h --help -help to print this help message
</span></span></code></pre></td></tr></table>
</div>
</div><p>一般使用时可按如下方式使用：加上<code>more</code>可以不必一下子展示出全部堆栈信息，引起刷屏，通过回车来分屏查看。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ jstack -l 26472 | more
</span></span></code></pre></td></tr></table>
</div>
</div><p>实际案例</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[user@server-name ~]$ jstack -l 37
</span></span><span class="line"><span class="cl">2022-08-04 15:51:44
</span></span><span class="line"><span class="cl">Full thread dump OpenJDK 64-Bit Server VM (11.0.14.1+1 mixed mode):
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Threads class SMR info:
</span></span><span class="line"><span class="cl">_java_thread_list=0x00007f420f686e60, length=420, elements={
</span></span><span class="line"><span class="cl">0x00007f422d20be00, 0x00007f422d20d200, 0x00007f422d20d700, 0x00007f422d20dc00,
</span></span><span class="line"><span class="cl">0x00007f422d20e100, 0x00007f420fc77000, 0x00007f420fc77600, 0x00007f420fc77c00,
</span></span><span class="line"><span class="cl">0x00007f422d20e600, 0x00007f420fd9b500, 0x00007f420fd9ce00, 0x00007f420fd9d300,
</span></span><span class="line"><span class="cl">0x00007f420fd9e200, 0x00007f42076bc500, 0x00007f42076bca00, 0x00007f42076bcf00,
</span></span><span class="line"><span class="cl">0x00007f42076bd400, 0x00007f42076bd900, 0x00007f42076bde00, 0x00007f42076be300,
</span></span><span class="line"><span class="cl">0x00007f41f8e94000, 0x00007f41f8e94500, 0x00007f41f8e94a00, 0x00007f41f8e94f00,
</span></span><span class="line"><span class="cl">0x00007f41f8e95400, 0x00007f41f8e95900, 0x00007f41f8e95e00, 0x00007f41f8e96300,
</span></span><span class="line"><span class="cl">0x00007f41f8e96800, 0x00007f41f8b08000, 0x00007f41f8b08500, 0x00007f41f8b08a00,
</span></span><span class="line"><span class="cl">0x00007f41f8b08f00, 0x00007f41f8b09400, 0x00007f42076be800, 0x00007f42076bf200,
</span></span><span class="line"><span class="cl">0x00007f42076c0100, 0x00007f42076c0600, 0x00007f42076c0b00, 0x00007f41eaeeb000,
</span></span><span class="line"><span class="cl">0x00007f41eaeeb500, 0x00007f41eaeeba00, 0x00007f41eaeebf00, 0x00007f41eaeec400,
</span></span><span class="line"><span class="cl">0x00007f41eaeec900, 0x00007f42076bed00, 0x00007f41eaeece00, 0x00007f41eaeed300,
</span></span><span class="line"><span class="cl">0x00007f420a63d000, 0x00007f41eaeed800, 0x00007f41eaeedd00, 0x00007f41eaeeec00,
</span></span><span class="line"><span class="cl">0x00007f41eaeefb00, 0x00007f41eaeee700, 0x00007f41db84d000, 0x00007f41db84d500,
</span></span><span class="line"><span class="cl">0x00007f41db84da00, 0x00007f41db84df00, 0x00007f41db84e400, 0x00007f41db84e900,
</span></span><span class="line"><span class="cl">0x00007f41db84ee00, 0x00007f41db84f300, 0x00007f41db84f800, 0x00007f41db84fd00,
</span></span><span class="line"><span class="cl">0x00007f41db850200, 0x00007f41db850700, 0x00007f41db850c00, 0x00007f41db851100,
</span></span><span class="line"><span class="cl">0x00007f41db851600, 0x00007f41db851b00, 0x00007f41eaa63000, 0x00007f41eaa63500,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 省略部分elements
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&#34;main&#34; #1 prio=5 os_prio=0 cpu=1650.00ms elapsed=7743.71s tid=0x00007f422d20be00 nid=0x40 runnable  [0x00007f4230c9b000]
</span></span><span class="line"><span class="cl">   java.lang.Thread.State: RUNNABLE
</span></span><span class="line"><span class="cl">        at java.net.PlainSocketImpl.socketAccept(java.base@11.0.14.1/Native Method)
</span></span><span class="line"><span class="cl">        at java.net.AbstractPlainSocketImpl.accept(java.base@11.0.14.1/AbstractPlainSocketImpl.java:474)
</span></span><span class="line"><span class="cl">        at java.net.ServerSocket.implAccept(java.base@11.0.14.1/ServerSocket.java:565)
</span></span><span class="line"><span class="cl">        at java.net.ServerSocket.accept(java.base@11.0.14.1/ServerSocket.java:533)
</span></span><span class="line"><span class="cl">        at org.apache.catalina.core.StandardServer.await(StandardServer.java:466)
</span></span><span class="line"><span class="cl">        at org.apache.catalina.startup.Catalina.await(Catalina.java:769)
</span></span><span class="line"><span class="cl">        at org.apache.catalina.startup.Catalina.start(Catalina.java:715)
</span></span><span class="line"><span class="cl">        at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(java.base@11.0.14.1/Native Method)
</span></span><span class="line"><span class="cl">        at jdk.internal.reflect.NativeMethodAccessorImpl.invoke(java.base@11.0.14.1/NativeMethodAccessorImpl.java:62)
</span></span><span class="line"><span class="cl">        at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(java.base@11.0.14.1/DelegatingMethodAccessorImpl.java:43)
</span></span><span class="line"><span class="cl">        at java.lang.reflect.Method.invoke(java.base@11.0.14.1/Method.java:566)
</span></span><span class="line"><span class="cl">        at org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:353)
</span></span><span class="line"><span class="cl">        at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:493)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   Locked ownable synchronizers:
</span></span><span class="line"><span class="cl">        - None
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&#34;Reference Handler&#34; #2 daemon prio=10 os_prio=0 cpu=345.87ms elapsed=7743.06s tid=0x00007f422d20d200 nid=0x4b waiting on condition  [0x00007f4230b5c000]
</span></span><span class="line"><span class="cl">   java.lang.Thread.State: RUNNABLE
</span></span><span class="line"><span class="cl">        at java.lang.ref.Reference.waitForReferencePendingList(java.base@11.0.14.1/Native Method)
</span></span><span class="line"><span class="cl">        at java.lang.ref.Reference.processPendingReferences(java.base@11.0.14.1/Reference.java:241)
</span></span><span class="line"><span class="cl">        at java.lang.ref.Reference$ReferenceHandler.run(java.base@11.0.14.1/Reference.java:213)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   Locked ownable synchronizers:
</span></span><span class="line"><span class="cl">        - None
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&#34;Finalizer&#34; #3 daemon prio=8 os_prio=0 cpu=37.68ms elapsed=7743.06s tid=0x00007f422d20d700 nid=0x4c in Object.wait()  [0x00007f4230b1b000]
</span></span><span class="line"><span class="cl">   java.lang.Thread.State: WAITING (on object monitor)
</span></span><span class="line"><span class="cl">        at java.lang.Object.wait(java.base@11.0.14.1/Native Method)
</span></span><span class="line"><span class="cl">        - waiting on &lt;no object reference available&gt;
</span></span><span class="line"><span class="cl">        at java.lang.ref.ReferenceQueue.remove(java.base@11.0.14.1/ReferenceQueue.java:155)
</span></span><span class="line"><span class="cl">        - waiting to re-lock in wait() &lt;0x000010017182af78&gt; (a java.lang.ref.ReferenceQueue$Lock)
</span></span><span class="line"><span class="cl">        at java.lang.ref.ReferenceQueue.remove(java.base@11.0.14.1/ReferenceQueue.java:176)
</span></span><span class="line"><span class="cl">        at java.lang.ref.Finalizer$FinalizerThread.run(java.base@11.0.14.1/Finalizer.java:170)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   Locked ownable synchronizers:
</span></span><span class="line"><span class="cl">        - None
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 省略剩余的堆栈
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="jcmd">jcmd</h3>
<p><code>jcmd</code>是在JDK1.7以后，新增了一个命令行工具。<code>jcmd</code>是一个多功能的工具，可以用它来导出堆、查看Java进程、导出线程信息、执行GC、还可以进行采样分析（jmc 工具的飞行记录器）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[user@server-name ~]$ jcmd -h
</span></span><span class="line"><span class="cl">Usage: jcmd &lt;pid | main class&gt; &lt;command ...|PerfCounter.print|-f file&gt;
</span></span><span class="line"><span class="cl">   or: jcmd -l
</span></span><span class="line"><span class="cl">   or: jcmd -h
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  command must be a valid jcmd command for the selected jvm.
</span></span><span class="line"><span class="cl">  Use the command &#34;help&#34; to see which commands are available.
</span></span><span class="line"><span class="cl">  If the pid is 0, commands will be sent to all Java processes.
</span></span><span class="line"><span class="cl">  The main class argument will be used to match (either partially
</span></span><span class="line"><span class="cl">  or fully) the class used to start Java.
</span></span><span class="line"><span class="cl">  If no options are given, lists Java processes (same as -l).
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  PerfCounter.print display the counters exposed by this process
</span></span><span class="line"><span class="cl">  -f  read and execute commands from the file
</span></span><span class="line"><span class="cl">  -l  list JVM processes on the local machine
</span></span><span class="line"><span class="cl">  -? -h --help print this help message
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="查看当前java进程">查看当前Java进程</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[user@server-name ~]$ jcmd
</span></span><span class="line"><span class="cl">2819 jdk.jcmd/sun.tools.jcmd.JCmd
</span></span><span class="line"><span class="cl">37 org.apache.catalina.startup.Bootstrap start
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>jcmd</code>，<code>jcmd -l</code>，<code>jps</code>三个命令都可以达到查看当前Java进程的效果。</p>
<h4 id="性能统计">性能统计</h4>
<p><code>jcmd ${pid} PerfCounter.print</code>，查看指定进程的性能统计信息。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[user@server-name ~]$ jcmd 37 PerfCounter.print
</span></span><span class="line"><span class="cl">37:
</span></span><span class="line"><span class="cl">java.ci.totalTime=171142524855
</span></span><span class="line"><span class="cl">java.cls.loadedClasses=20965
</span></span><span class="line"><span class="cl">java.cls.sharedLoadedClasses=0
</span></span><span class="line"><span class="cl">java.cls.sharedUnloadedClasses=0
</span></span><span class="line"><span class="cl">java.cls.unloadedClasses=0
</span></span><span class="line"><span class="cl">// 省略其他信息
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="当前运行的-java-进程可以执行的操作">当前运行的 java 进程可以执行的操作</h4>
<p><code>jcmd ${pid} help</code>使用这个命令，可以查看<code>jcmd</code>可以执行哪些操作，可以理解过对其他部分指令的一个封装。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[user@server-name ~]$ jcmd 37 help
</span></span><span class="line"><span class="cl">37:
</span></span><span class="line"><span class="cl">The following commands are available:
</span></span><span class="line"><span class="cl">// 省略部分信息
</span></span><span class="line"><span class="cl">GC.finalizer_info
</span></span><span class="line"><span class="cl">GC.heap_dump
</span></span><span class="line"><span class="cl">GC.heap_info
</span></span><span class="line"><span class="cl">// 省略部分信息
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">For more information about a specific command use &#39;help &lt;command&gt;&#39;.
</span></span></code></pre></td></tr></table>
</div>
</div><p>举个例子：使用<code>jcmd 37 VM.uptime</code>查看VM的运行时长</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[user@server-name ~]$ jcmd 37 VM.uptime
</span></span><span class="line"><span class="cl">37:
</span></span><span class="line"><span class="cl">9435.434 s
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里列举几个等价的命令：</p>
<ul>
<li><code>jcmd PID GC.class_histogram</code>，查看系统中类统计信息，等价于<code>jmap -histo pid</code>。</li>
<li><code>jcmd PID Thread.print</code>，查看线程堆栈信息，等价于<code>jstack -l pid</code>。</li>
<li><code>jcmd PID GC.heap_dump FILE_NAME</code>，查看 JVM 的Heap Dump，等价于<code>jmap -dump:format=b,file=heapdump.phrof pid</code>。</li>
</ul>
<h3 id="jsadebugd">jsadebugd</h3>
<p>命令格式：<code>jsadebugd PID [ServerId]</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">jsadebugd pid [ server-id ]
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">jsadebugd executable core [ server-id ]
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">pid
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    The process ID of the process to which the debug server attaches. The process must be a Java process. To get a list of Java processes running on a machine, use the jps(1) command. At most one instance of the debug server can be attached to a single process.
</span></span><span class="line"><span class="cl">executable
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    The Java executable from which the core dump was produced.
</span></span><span class="line"><span class="cl">core
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    The core file to which the debug server should attach.
</span></span><span class="line"><span class="cl">server-id
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    An optional unique ID that is needed when multiple debug servers are started on the same machine. This ID must be used by remote clients to identify the particular debug server to which to attach. Within a single machine, this ID must be unique.
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>使用jinfo，jmap，jstack命令不仅可监控本地主机上的JVM进程，也可监控远端主机上的JVM进程，前者称为“本地模式”，后者称为“联网模式”。“联网模式”下的整个监控体系实质上是一个RMI应用程序。在“联网模式”下，一般情况下，远端主机上“运行rmiregistry服务，运行RMI Server”，本地主机上“运行RMI Client”，整个体系中“无需运行Web Server服务（因为所有相关类都可在本地获取）”。</p>
<p>在远端主机上，通过运行jsadebugd命令开启RMI Server（需要注意的是，运行jsadebugd命令同时会自动运行rmiregistry服务，而无需手动运行），使用“PID”选项值指定远端主机上待被监控的JVM进程ID，使用“ServerId”选项值作为RMI Server内向rmiregistry服务注册所生成Remote Object实例的名称（如果未指定，则使用默认名称）；在本地主机上，运行jinfo，jmap，jstack命令作为RMI Client。</p>
</blockquote>
<p><code>jsadebugd</code>在JDK11中已经没有这个命令，这里不再过多介绍。</p>
<h2 id="monitor-the-jvm">Monitor the JVM</h2>
<h3 id="jps">jps</h3>
<p><code>jps</code>：虚拟机进程状况工具，<code>JVM Process Status Tool</code>的缩写，显示指定系统内所有的HotSpot虚拟机进程。<code>jps</code>可以有什么用处呢？</p>
<ol>
<li>可以列出正在运行的虚拟机进程；</li>
<li>显示虚拟机执行主类（main函数坐在的类）名称；</li>
<li>显示进程的本地虚拟机唯一ID（Local Virtual Machine Identifier，LVMID）；</li>
</ol>
<ul>
<li>
<p>jps是使用频率最高的JDK命令行工具，因为其他的JDK工具大多数需要输入它查询到的LVMID来确定要监控的是哪一个虚拟机进程。</p>
</li>
<li>
<p>对于本地虚拟机进程来说，LVMID与操作系统的进程ID ( Process Identifier,PID ) 是一致的。</p>
</li>
<li>
<p>使用Windows的任务管理器或者UNIX的ps命令也可以查询到虚拟机进程的LVMID ，但如果同时启动了多个虚拟机进程，无法根据进程名称定位时，那就只能依赖jps命令显示主类的功能才能区分了。</p>
</li>
<li>
<p>jps命令格式： jps [options] [hostid]</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[user@server-name ~]$ jps -h
</span></span><span class="line"><span class="cl">usage: jps [--help]
</span></span><span class="line"><span class="cl">       jps [-q] [-mlvV] [&lt;hostid&gt;]
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Definitions:
</span></span><span class="line"><span class="cl">    &lt;hostid&gt;:      &lt;hostname&gt;[:&lt;port&gt;]
</span></span><span class="line"><span class="cl">    -? -h --help -help: Print this help message and exit.
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>jps可以通过RMI协议查询开启了RMI服务的远程虚拟机进程状态，hostid为RMI注册表中注册的主机名。</li>
<li>需要远程主机提供RMI支持，Sun提供的jstatd工具可以很方便地建立远程RMI服务器。</li>
</ul>
<p>各个参数执行后详情：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[user@server-name  ~]$ jps -l
</span></span><span class="line"><span class="cl">3436 jdk.jcmd/sun.tools.jps.Jps
</span></span><span class="line"><span class="cl">[user@server-name ~]$ jps -m
</span></span><span class="line"><span class="cl">3463 Jps -m
</span></span><span class="line"><span class="cl">[user@server-name  ~]$ jps -v
</span></span><span class="line"><span class="cl">3483 Jps -Dapplication.home=/usr/java/jdk11 -Xms8m -Djdk.module.main=jdk.jcmd
</span></span><span class="line"><span class="cl">[user@server-name  ~]$ jps -V
</span></span><span class="line"><span class="cl">3502 Jps
</span></span><span class="line"><span class="cl">[user@server-name  ~]$ jps -q
</span></span><span class="line"><span class="cl">3549
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="jstat">jstat</h3>
<p>jstat: 虚拟机统计信息监视工具，<code>JVM Statistics Monitoring Tool</code>的缩写，用于收集HotSpot虚拟机各方面的运行数据。它可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</p>
<p>在没有GUI图形界面，只提供了纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的首选工具。</p>
<p><code>jstat</code>命令格式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">jstat [option vmid [interval [s|ms] [count]] ]
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[user@server-name ~]$ jstat
</span></span><span class="line"><span class="cl">Usage: jstat --help|-options
</span></span><span class="line"><span class="cl">       jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Definitions:
</span></span><span class="line"><span class="cl">  &lt;option&gt;      An option reported by the -options option
</span></span><span class="line"><span class="cl">  &lt;vmid&gt;        Virtual Machine Identifier. A vmid takes the following form:
</span></span><span class="line"><span class="cl">                     &lt;lvmid&gt;[@&lt;hostname&gt;[:&lt;port&gt;]]
</span></span><span class="line"><span class="cl">                Where &lt;lvmid&gt; is the local vm identifier for the target
</span></span><span class="line"><span class="cl">                Java virtual machine, typically a process id; &lt;hostname&gt; is
</span></span><span class="line"><span class="cl">                the name of the host running the target Java virtual machine;
</span></span><span class="line"><span class="cl">                and &lt;port&gt; is the port number for the rmiregistry on the
</span></span><span class="line"><span class="cl">                target host. See the jvmstat documentation for a more complete
</span></span><span class="line"><span class="cl">                description of the Virtual Machine Identifier.
</span></span><span class="line"><span class="cl">  &lt;lines&gt;       Number of samples between header lines.
</span></span><span class="line"><span class="cl">  &lt;interval&gt;    Sampling interval. The following forms are allowed:
</span></span><span class="line"><span class="cl">                    &lt;n&gt;[&#34;ms&#34;|&#34;s&#34;]
</span></span><span class="line"><span class="cl">                Where &lt;n&gt; is an integer and the suffix specifies the units as
</span></span><span class="line"><span class="cl">                milliseconds(&#34;ms&#34;) or seconds(&#34;s&#34;). The default units are &#34;ms&#34;.
</span></span><span class="line"><span class="cl">  &lt;count&gt;       Number of samples to take before terminating.
</span></span><span class="line"><span class="cl">  -J&lt;flag&gt;      Pass &lt;flag&gt; directly to the runtime system.
</span></span><span class="line"><span class="cl">  -? -h --help  Prints this help message.
</span></span><span class="line"><span class="cl">  -help         Prints this help message.
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[user@server-name ~]$ jstat -options
</span></span><span class="line"><span class="cl">-class
</span></span><span class="line"><span class="cl">-compiler
</span></span><span class="line"><span class="cl">-gc
</span></span><span class="line"><span class="cl">-gccapacity
</span></span><span class="line"><span class="cl">-gccause
</span></span><span class="line"><span class="cl">-gcmetacapacity
</span></span><span class="line"><span class="cl">-gcnew
</span></span><span class="line"><span class="cl">-gcnewcapacity
</span></span><span class="line"><span class="cl">-gcold
</span></span><span class="line"><span class="cl">-gcoldcapacity
</span></span><span class="line"><span class="cl">-gcutil
</span></span><span class="line"><span class="cl">-printcompilation
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>对于命令格式中的<code>VMID</code>与<code>LVMID</code>需要特别说明一下:
<ul>
<li>如果是本地虚拟机进程，<code>VMID</code>与<code>LVMID</code>是一致的；</li>
<li>如果是远程虚拟机进程，那<code>VMID</code>的格式应当是: [protocol:][//]lvmid[@hostname[:port]/servername]</li>
</ul>
</li>
<li>参数<code>interval</code>和<code>count</code>代表<code>查询间隔</code>和<code>次数</code>，如果省略这两个参数，说明只<code>查询一次</code>。
<ul>
<li>假设需要每250毫秒查询一次进程2764垃圾收集状况，一共查询20次，那命令应当是：<code>jstat -gc 2764 250 20</code></li>
</ul>
</li>
<li>选项<code>option</code>代表着用户希望查询的虚拟机信息，主要分为3类：类装载、垃圾收集、运行期编译状况。
<ul>
<li>类装载
<ul>
<li><code>-class</code>：监视类装载、卸载数量、总空间以及类装载所耗费的时间。</li>
</ul>
</li>
<li>垃圾收集
<ul>
<li><code>-gc</code>：监视Java堆状况，包括Eden区、两个survivor区、老年代、永久代等的容量、已用空间、GC时间合计等信息</li>
<li><code>-gccapacity</code>：监视内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大、最小空间</li>
<li><code>-gcutil</code>：监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比</li>
<li><code>-gccause</code>：与-gcutil功能一样，但是会额外输出导致上一次GC产生的原因</li>
<li><code>-gcnew</code>：监视新生代GC状况</li>
<li><code>-gcnewcapacity</code>：监视内容与-gcnew基本相同，输出主要关注使用到的最大、最小空间</li>
<li><code>-gcold</code>：监视老年代GC状况</li>
<li><code>-gcoldcapacity</code>：监视内容与-gcold基本相同，输出主要关注使用到的最大、最小空间</li>
<li><code>-gcpermcapacity</code>：输出永久代使用到的最大、最小空间</li>
</ul>
</li>
<li>运行期编译状况
<ul>
<li><code>-compiler</code>：输出JIT编译器编译过的方法、耗时等信息</li>
<li><code>-printcompilation</code>：输出已经被JIT编译的方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>GC优化中，利用<code>jstat -gc ${pid}</code>较多，实际执行如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[user@server-name ~]$ jstat -gc 37
</span></span><span class="line"><span class="cl"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT    CGC    CGCT     GCT
</span></span><span class="line"><span class="cl">  -      -      -      -       -        -     6213632.0  1847296.0  135680.0 133830.1  0.0    0.0        -        -   -          -   -          -    0.000
</span></span></code></pre></td></tr></table>
</div>
</div><p>每隔一秒打印GC信息，输出10次。<code>jstat -gc 37 1000 10</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[user@server-name ~]$ jstat -gc 37 1000 10
</span></span><span class="line"><span class="cl"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT    CGC    CGCT     GCT
</span></span><span class="line"><span class="cl">  -      -      -      -       -        -     6213632.0  2279424.0  135680.0 133855.6  0.0    0.0        -        -   -          -   -          -    0.000
</span></span><span class="line"><span class="cl">  -      -      -      -       -        -     6213632.0  2279424.0  135680.0 133855.6  0.0    0.0        -        -   -          -   -          -    0.000
</span></span><span class="line"><span class="cl">  -      -      -      -       -        -     6213632.0  2279424.0  135680.0 133855.6  0.0    0.0        -        -   -          -   -          -    0.000
</span></span><span class="line"><span class="cl">  -      -      -      -       -        -     6213632.0  2279424.0  135680.0 133855.6  0.0    0.0        -        -   -          -   -          -    0.000
</span></span><span class="line"><span class="cl">  -      -      -      -       -        -     6213632.0  2279424.0  135680.0 133855.6  0.0    0.0        -        -   -          -   -          -    0.000
</span></span><span class="line"><span class="cl">  -      -      -      -       -        -     6213632.0  2279424.0  135680.0 133855.6  0.0    0.0        -        -   -          -   -          -    0.000
</span></span><span class="line"><span class="cl">  -      -      -      -       -        -     6213632.0  2279424.0  135680.0 133855.6  0.0    0.0        -        -   -          -   -          -    0.000
</span></span><span class="line"><span class="cl">  -      -      -      -       -        -     6213632.0  2279424.0  135680.0 133855.6  0.0    0.0        -        -   -          -   -          -    0.000
</span></span><span class="line"><span class="cl">  -      -      -      -       -        -     6213632.0  2279424.0  135680.0 133855.6  0.0    0.0        -        -   -          -   -          -    0.000
</span></span><span class="line"><span class="cl">  -      -      -      -       -        -     6213632.0  2279424.0  135680.0 133855.6  0.0    0.0        -        -   -          -   -          -    0.000
</span></span></code></pre></td></tr></table>
</div>
</div><p>具体的参数说明：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>S0C</td>
<td>年轻代中第一个survivor区的容量（字节）</td>
</tr>
<tr>
<td>S1C</td>
<td>年轻代中第二个survivor区的容量（字节）</td>
</tr>
<tr>
<td>S0U</td>
<td>年轻代中第一个survivor区目前已使用空间（字节）</td>
</tr>
<tr>
<td>S1U</td>
<td>年轻代中第二个survivor区目前已使用空间（字节）</td>
</tr>
<tr>
<td>EC</td>
<td>年轻代中Eden区的容量 (字节)</td>
</tr>
<tr>
<td>EU</td>
<td>年轻代中Eden区目前已使用空间（字节）</td>
</tr>
<tr>
<td>OC</td>
<td>老年代的容量（字节）</td>
</tr>
<tr>
<td>OU</td>
<td>老年代目前已使用空间（字节）</td>
</tr>
<tr>
<td>PC</td>
<td>Perm（永久代）的容量（字节）</td>
</tr>
<tr>
<td>PU</td>
<td>Perm（永久代）目前已使用空间（字节）</td>
</tr>
<tr>
<td>YGC</td>
<td>从应用程序启动到采样时年轻代中gc次数</td>
</tr>
<tr>
<td>YGCT</td>
<td>从应用程序启动到采样时年轻代中gc所用时间（s）</td>
</tr>
<tr>
<td>FGC</td>
<td>从应用程序启动到采样时老年代（全gc）gc次数</td>
</tr>
<tr>
<td>FGCT</td>
<td>从应用程序启动到采样时老年代（全gc）gc所用时间（s）</td>
</tr>
<tr>
<td>GCT</td>
<td>从应用程序启动到采样时gc用的总时间（s）</td>
</tr>
</tbody>
</table>
<p><code>jstat -class</code>命令执行情况。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[user@server-name ~]$ jstat -class 37
</span></span><span class="line"><span class="cl">Loaded  Bytes  Unloaded  Bytes     Time
</span></span><span class="line"><span class="cl"> 21021 39147.3        0     0.0      17.62
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>jstat -compiler</code>命令执行情况。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[user@server-name ~]$ jstat -compiler 37
</span></span><span class="line"><span class="cl">Compiled Failed Invalid   Time   FailedType FailedMethod
</span></span><span class="line"><span class="cl">   33141      2       0   182.55          1 com/mysql/jdbc/AbandonedConnectionCleanupThread run
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="jmc">jmc</h3>
<p><code>jmc</code>是<code>Java Mission Control</code>的缩写，是一个集成了分析、监视和诊断等功能的工具套件，可以用于对<code>HotSpot JVM</code>进行生产时间分析和诊断的工具。<code>jmc</code>的两个主要功能是<code>管理控制台</code>和<code>Java飞行记录仪</code>，但还有一些功能是作为插件提供的，可以从该工具下载。<code>jmc</code>也可以作为Eclipse IDE的一组插件使用。</p>
<p>官方文档：https://docs.oracle.com/en/java/java-components/jdk-mission-control/8/user-guide/</p>
<p>JMC的两大功能如下图：
<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17b6207b91bf403783a9cc32223163c7~tplv-k3u1fbpfcp-watermark.image?" alt="jmc-type.png"></p>
<p>其中<code>MBean服务器</code>是免费的，<code>飞行记录器(Java Flight Recorder)</code>是需要收费的。</p>
<h4 id="服务端如何开启jmc">服务端如何开启jmc</h4>
<p>首先，JDK从JDK8-u265版本开始支持<code>jmc</code>，如果需要想要使用<code>jmc</code>需要先明确jdk的版本，如果过低需要升级才可以。</p>
<p>在确定JDK版本支持jmc后，需要在<code>/tomcat/bin/setenv.sh</code>文件的<code>JAVA_OPTS</code>属性中添加<code>-XX:StartFlightRecording \</code>这样一句话。可以直接手动修改，也可以使用<code>sed</code>命令添加内容，如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">sudo sed -i &#39;/Dcom.sun.management.jmxremote.ssl/a-XX:StartFlightRecording \\&#39; /opt/tomcat/bin/setenv.sh
</span></span></code></pre></td></tr></table>
</div>
</div><p>添加后效果如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">JAVA_OPTS=&#34;${JAVA_OPTS} \
</span></span><span class="line"><span class="cl">            # 省略不相关配置
</span></span><span class="line"><span class="cl">           -Dcom.sun.management.jmxremote \
</span></span><span class="line"><span class="cl">           # 8780端口需要记住，在jmc远程连接时，需要填写
</span></span><span class="line"><span class="cl">           -Dcom.sun.management.jmxremote.port=8780 \
</span></span><span class="line"><span class="cl">           -Dcom.sun.management.jmxremote.rmi.port=8780 \
</span></span><span class="line"><span class="cl">           -Dcom.sun.management.jmxremote.authenticate=false \
</span></span><span class="line"><span class="cl">           -c=false \
</span></span><span class="line"><span class="cl">           # 需要添加的配置项
</span></span><span class="line"><span class="cl">           -XX:StartFlightRecording \
</span></span><span class="line"><span class="cl">            # 省略不相关配置
</span></span><span class="line"><span class="cl">           &#34;
</span></span></code></pre></td></tr></table>
</div>
</div><p>修改配置后，重启tomcat容器。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">sudo supervisorctl restart tomcat
</span></span></code></pre></td></tr></table>
</div>
</div><p>属性介绍：</p>
<ul>
<li><code>-Dcom.sun.management.jmxremote</code>
<ul>
<li>此选项用于切换 JMXRMI 的使用。默认情况下启用该选项，因此无需设置该选项就可以使用 JVM 的监视功能。要为 JVM 禁用 JMXRMI，请指定 -Dcom.sun.management.jmxremote=false。</li>
</ul>
</li>
<li><code>-Dcom.sun.management.jmxremote.authenticate</code>
<ul>
<li>该选项用于切换对 JMXRMI 连接使用口令验证。默认情况下此选项是启用的。要为 JVM 禁用口令验证，请指定 -Dcom.sun.management.jmxremote.authenticate=false。</li>
<li>注意：禁用验证是不安全的。任何知道 (或猜中) JMX 端口号和主机名的远程用户都能够监视和控制 Java 应用程序和 VM。虽然开发时这是可接受的，但对于生产系统不建议这样设置。</li>
</ul>
</li>
<li><code>-Dcom.sun.management.jmxremote.port</code>
`   - 此选项用于设置 JMXRMI 连接的端口号。必须设置未使用的端口号才能启用 JVM 的监视和管理功能。</li>
<li><code>-Dcom.sun.management.jmxremote.ssl</code>
<ul>
<li>此选项用于切换安全套接字层 Sockets Layer (SSL) 验证的使用。默认情况下启用该选项。要为 JVM 禁用 SSL 验证，请指定 -Dcom.sun.management.jmxremote.ssl=false。</li>
</ul>
</li>
</ul>
<h4 id="jmc在哪里">jmc在哪里</h4>
<p>从Java11开始，Java分为了OracleJDK和AdoptOpenJDK两个版本，目前由于版权问题，都要求使用开源的<code>AdoptOpenJDK</code>，这里就有一个问题，在<code>AdoptOpenJDK</code>的<code>bin</code>目录下是找不到<code>jmc</code>应用的。有几个方法可以解决</p>
<ol>
<li>如果安装过JDK8-u265以上版本，可以使用jdk8 bin目录下的<code>jmc</code>，这个不受服务端jdk版本影响，也就是说如果应用是jdk11，我用jdk
8的jmc仍然可以进行问题分析。</li>
<li>如果只安装了jdk11甚至更高版本的jdk。可以单独下载jmc
<ul>
<li>openjdk的jmc官网地址：https://openjdk.org/projects/jmc/
<ul>
<li>github地址：https://github.com/openjdk/jmc</li>
</ul>
</li>
<li>Oracle的jmc下载：https://www.oracle.com/java/technologies/jdk-mission-control.html</li>
</ul>
</li>
</ol>
<h4 id="mbean服务器">MBean服务器</h4>
<p>详细的使用可以参考：<a href="https://www.jianshu.com/p/9baea772cb21">JVM——jmc使用说明</a>，以下部分内容也援引此文。</p>
<p>创建新的连接。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0639eb7eddcb421691fdc99d29a3ed4b~tplv-k3u1fbpfcp-watermark.image?" alt="jmc-new-connect.png"></p>
<h5 id="overview">overview</h5>
<p>默认布局提供 CPU 和内存使用情况的概览。</p>
<p>概览：可以添加自定义图表，通过概览的加号”添加图表”实现；可以重置，通过”重置为默认控件”实现。
添加图表后，可以通过图表的加号添加相应的子项，并可以在图表上右键详细设置。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d58556cbcad54c978989574f419d25a9~tplv-k3u1fbpfcp-watermark.image?" alt="jmc-overview.png"></p>
<h5 id="mbean-brower">mbean-brower</h5>
<p>JMC使用托管Bean (MBean) 为监视和管理 Java 应用程序性能提供统一且一致的界面。MBean 是采用符合 JMX 规范的设计模式的托管对象。MBean 可以表示一个设备、一个应用程序或需要托管的任何资源。MBean 的管理界面由一组属性、操作和通知组成。</p>
<p>MBean功能：</p>
<ol>
<li>属性：列出所选 MBean 的属性。</li>
<li>操作：列出可从所选 MBean 调用的操作。</li>
<li>通知：列出在运行时期间 MBean 所提示的通知。</li>
<li>元数据：包含描述 MBean 的信息。</li>
</ol>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3a499277a55419889dfdadb9173302e~tplv-k3u1fbpfcp-watermark.image?" alt="jmc-mbean-brower.png"></p>
<h5 id="trigger">trigger</h5>
<p>使用触发器选项卡可以管理满足特定条件时触发事件的规则。这是一种无需持续地监视应用程序即可跟踪运行时问题的有用方法。以灰色显示的规则在监视的 JVM 中不可用。默认情况下，停用所有规则。要激活某个规则，请选中该规则旁边的复选框。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a94863fadaaf403091a58a7efee5d910~tplv-k3u1fbpfcp-watermark.image?" alt="jmc-trigger.png"></p>
<h5 id="system">system</h5>
<p>系统选项卡提供了运行 JVM 的系统的信息、JVM 的性能属性以及系统属性列表。</p>
<ul>
<li>服务器信息
<ul>
<li>在系统选项卡顶部的服务器信息面板中，包含运行 JVM 的服务器的类别和值列表。这些信息对调试应用程序开发问题和运行时问题以及提出支持请求非常有用。这是一般系统信息，不能更改。</li>
</ul>
</li>
<li>JVM 统计信息
<ul>
<li>JVM 统计信息面板包含 JVM 主要性能属性的当前值。默认情况下，表中显示以下属性：</li>
</ul>
</li>
<li>当前已加载类计数
<ul>
<li>运行时间</li>
<li>要向表中添加属性，请单击 JVM 统计信息面板右上角的添加属性按钮。要删除属性，请在表中右键单击该属性，然后选择删除。右键单击属性后，可以更改其更新间隔、单位，而对于一些属性，还可以设置值。</li>
</ul>
</li>
<li>系统属性
<ul>
<li>系统属性面板包含一个表，其中列出使用 JVM 调用的所有属性的关键字和值。要筛选属性，请选择筛选列 (关键字或值)，并在表上方的文本字段中指定筛选器字符串。</li>
<li>要配置表外观，请单击系统属性面板右上角的表设置按钮，然后选择要显示或隐藏的列。对于各列，可以设置最小宽度、比例和初始排序顺序。展示的是一般系统信息，不能更改。</li>
</ul>
</li>
</ul>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87878b675a674dc49c9674f4adc9a4e5~tplv-k3u1fbpfcp-watermark.image?" alt="jmc-system.png"></p>
<h5 id="memory">memory</h5>
<p>使用内存选项卡可以监视应用程序使用内存资源的效率。此选项卡主要提供以下方面的信息：堆使用量、垃圾收集和活动内存池。此选项卡上提供的信息可帮助确定是否已将 JVM 配置为提供最佳应用程序性能。</p>
<ul>
<li>GC表
<ul>
<li>GC 表面板包含可用垃圾收集器的主要性能属性的当前值。该面板分为标有活动垃圾收集器名称的多个选项卡
<ul>
<li>总收集时间</li>
<li>收集计数</li>
<li>GC 开始时间</li>
<li>GC 结束时间</li>
<li>GC 持续时间</li>
<li>GC ID</li>
<li>GC 线程计数</li>
</ul>
</li>
</ul>
</li>
<li>活动内存池
<ul>
<li>活动内存池面板包含一个表，其中列出可供 JVM 使用的内存池的信息。默认情况下，该表包含以下列：
<ul>
<li>池名称：内存池的名称。</li>
<li>类型：内存池的类型。如果内存池属于 Java 堆，则类型为 HEAP，否则为 NON_HEAP。</li>
<li>已用：当前已用的内存池大小。</li>
<li>最大值：内存池的最大大小。</li>
<li>占用率：当前使用量占最大内存池大小的百分比。</li>
<li>已用峰值：在受监视 JVM 的有效期内内存池已用内存的峰值。</li>
<li>最大值峰值：在受监视 JVM 的有效期内最大内存池大小的峰值。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ed243c127e9497abe7f685bc81b0336~tplv-k3u1fbpfcp-watermark.image?" alt="jmc-memory.png"></p>
<h5 id="thread">thread</h5>
<p>使用线程选项卡可以监视线程活动。此选项卡包含一个绘制应用程序随时间推移的活动线程使用情况的图形、一个由该应用程序使用的所有活动线程的表以及选定线程的堆栈跟踪。</p>
<ul>
<li>活动线程图
<ul>
<li>活动线程图显示 Java 应用程序随时间推移启动的线程数。默认情况下，图形中显示以下属性：
<ul>
<li>高峰活动线程计数</li>
<li>活动线程总计数</li>
<li>守护程序活动线程计数</li>
</ul>
</li>
</ul>
</li>
<li>活动线程
<ul>
<li>活动线程面板包含一个表，其中列出 Java 应用程序所启动活动线程的信息。默认情况下，该表包含以下列：
<ul>
<li>线程名称：线程的名称。</li>
<li>线程状态：线程的状态。线程可以是以下状态之一：NEW、RUNNABLE、BLOCKED、WAITING、TIMED_WAITING 或 TERMINATED。</li>
<li>受阻计数：线程处于 BLOCKED 状态的次数。</li>
<li>CPU 总体占用率：线程所使用 CPU 资源占总 CPU 资源的百分比。默认情况下不提取此值。要启用它，请在表上方选择 CPU 概要分析。</li>
<li>死锁：线程是否已死锁。默认情况下不提取此值。要启用它，请在表上方选择死锁检测。</li>
<li>已分配的字节：已分配给线程的字节数。默认情况下不提取此值。要启用它，请在表上方选择分配。</li>
</ul>
</li>
</ul>
</li>
<li>选定线程的堆栈跟踪
<ul>
<li>在活动线程表中选择线程后，其整个堆栈跟踪将显示在下面的选定线程的堆栈跟踪面板中。堆栈跟踪包含所有方法 (一直到当前执行的方法) 的调用路径。它非常有用，例如，当需要确定导致死锁或代码执行过程中意外中断的方法时。</li>
</ul>
</li>
</ul>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a120b1c40a304169b2d80e5ffc2d9bb9~tplv-k3u1fbpfcp-watermark.image?" alt="jmc-thread.png"></p>
<h5 id="command">command</h5>
<p>使用诊断命令可监视 Java 应用程序的效率和性能。JMC 使用大量不同的诊断工具，包括一组可以使用诊断命令选项卡针对应用程序运行的命令。
<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c121579f9ce642a49405c904aaeab114~tplv-k3u1fbpfcp-watermark.image?" alt="jmc-command.png"></p>
<h3 id="jstatd">jstatd</h3>
<p><code>jstatd</code>用于启动jvm监控服务。它是一个基于rmi的应用，向远程机器提供本机jvm应用程序的信息。默认端口1099。只能够监控具有适当的本地访问权限的JVM。因此，jstatd进程必须以与目标JVM相同的用户凭证来运行。</p>
<p><code>jstatd</code>使用的并不多，只作为了解即可。</p>
<h2 id="monitor-java-applications">Monitor Java Applications</h2>
<p><code>JConsole</code>是在JDK 1.5时期就已经提供的虚拟机监控工具，而<code>Java VisualVM</code>在JDK 1.6 Update7中才首次发布，现在已经成为Sun ( Oracle ) 主力推动的多合一故障处理工具，并且已经从JDK中分离出来成为可以独立发展的开源项目。</p>
<h3 id="jconsole">jconsole</h3>
<p><code>jconsole</code>（Java Monitoring and Management Console）: JVM 性能监控，是—种基于JMX的可视化监视管理工具。它管理部分的功能是针对JMX MBean进行管理，由于MBean可以使用代码、中间件服务器的管理控制台或者所有符合JMX规范的软件进行访问，所以本节将会着重介绍JConsole监视部分的功能。</p>
<p><code>jconsole</code>逐步被<code>jvisualvm</code>替代，因此这里只需要了解有<code>jconsole</code>即可，就不做过多的展开说明。</p>
<h3 id="visualvmall-in-one-java-troubleshooting-tool">VisualVM（All-in-One Java Troubleshooting Tool）</h3>
<p><code>Java VisualVM</code>也被称为<code>jvisualvm</code>或<code>VisualVM</code>，是到目前为止随JDK发布的功能最强大的运行监视和故障处理程序，并且可以预见在未来一段时间内都是官方主力发展的虚拟机故障处理工具。它拥有自己独立的官网：https://visualvm.github.io/index.html。</p>
<p>官方在VisualVM的软件说明中写上了<em>All-in-One</em>的描述字样，预示着它除了运行监视、故障处理外，还提供了很多其他方面的功能，如性能分析(Profiling)，VisualVM的性能分析功能甚至比起JProfiler、YourKit等专业且收费的Profiling工具都不会逊色多少。</p>
<p>而且VisualVM的还有一个很大的优点：不需要被监视的程序基于特殊 Agent运行，因此它对应用程序的实际性能的影响很小，使得它可以直接应用在生产环境中。这个优点是JProfiler、YourKit等工具无法与之媲美的。</p>
<p>VisualVM基于NetBeans平台开发，因此它一开始就具备了插件扩展功能的特性，通过插件扩展支持，VisualVM可以做到:</p>
<ol>
<li>显示虚拟机进程以及进程的配置、环境信息(jps、 jinfo)。</li>
<li>监视应用程序的CPU、GC、堆、方法区以及线程的信息(jstat、jstack)。</li>
<li>dump以及分析堆转储快照(jmap、jhat)。</li>
<li>方法级的程序运行性能分析，找出被调用最多、运行时间最长的方法。</li>
<li>离线程序快照:收集程序的运行时配置、线程dump、内存dump等信息建立个快照, 可以将快照发送开发者处进行Bug反馈。</li>
<li>其他plugins的无限的可能性
<ul>
<li>现有插件官网地址：https://visualvm.github.io/plugins.html，可以选择自己需要的合适插件。</li>
</ul>
</li>
</ol>
<h4 id="btrace">BTrace</h4>
<p>BTrace是一个很<em>有趣</em>的VisualVM插件，可以负责动态日志跟踪，本身也是可以独立运行的程序。</p>
<p>它的作用是在不停止目标程序运行的前提下，通过HotSpot虚拟机的HotSwap技术动态加入原本并不存在的调试代码。</p>
<p>这项功能对实际生产中的程序很有意义：经常遇到程序出现问题，但排查错误的一些必要信息，譬如方法参数、返回值等，在开发时并没有打印到日志之中，以至于不得不停掉服务，通过调试增量来加入日志代码以解决问题。当遇到生产环境服务无法随便停止时，缺一两句日志导致排错进行不下去是一件非常郁闷的事情。</p>
<p>这里额外提一点，BTrace是后文中准备介绍的arthas的基础开源框架，arthas也是在BTrace基础上升级而来。</p>
<h1 id="arthas">arthas</h1>
<blockquote>
<p>Arthas 是一款线上监控诊断产品，通过全局视角实时查看应用 load、内存、gc、线程的状态信息，并能在不修改应用代码的情况下，对业务问题进行诊断，包括查看方法调用的出入参、异常，监测方法执行耗时，类加载信息等，大大提升线上问题排查效率。</p>
</blockquote>
<p>arthas官方地址：https://arthas.aliyun.com/doc/quick-start.html</p>
<p>github地址：https://github.com/alibaba/arthas</p>
<h2 id="start-arthas">start arthas</h2>
<p>在命令行下面执行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">curl -O https://arthas.aliyun.com/arthas-boot.jar
</span></span><span class="line"><span class="cl">java -jar arthas-boot.jar
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>使用和目标进程一致的用户启动，否则可能 attach 失败。</p>
</blockquote>
<p>运行截图：
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb712e459fa444cf8ad58e502453d1ad~tplv-k3u1fbpfcp-watermark.image?" alt="arthas-start.png"></p>
<h2 id="help">help</h2>
<p>arthas启动后，可以通过<code>help</code>命令查看有哪些指令可使用，可以作为临时的开发手册。后续只是简单介绍一些常用的命令，未介绍到的可以翻阅官方文档使用，使用起来都很方面简洁。</p>
<p>命令列表：https://arthas.aliyun.com/doc/commands.html</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[arthas@5301]$ help
</span></span><span class="line"><span class="cl"> NAME         DESCRIPTION
</span></span><span class="line"><span class="cl"> help         Display Arthas Help
</span></span><span class="line"><span class="cl"> keymap       Display all the available keymap for the specified connection.
</span></span><span class="line"><span class="cl"> sc           Search all the classes loaded by JVM
</span></span><span class="line"><span class="cl"> sm           Search the method of classes loaded by JVM
</span></span><span class="line"><span class="cl"> classloader  Show classloader info
</span></span><span class="line"><span class="cl"> jad          Decompile class
</span></span><span class="line"><span class="cl"> getstatic    Show the static field of a class
</span></span><span class="line"><span class="cl"> monitor      Monitor method execution statistics, e.g. total/success/failure count, average rt, fail rate, etc.
</span></span><span class="line"><span class="cl"> stack        Display the stack trace for the specified class and method
</span></span><span class="line"><span class="cl"> thread       Display thread info, thread stack
</span></span><span class="line"><span class="cl"> trace        Trace the execution time of specified method invocation.
</span></span><span class="line"><span class="cl"> watch        Display the input/output parameter, return object, and thrown exception of specified method invocation
</span></span><span class="line"><span class="cl"> tt           Time Tunnel
</span></span><span class="line"><span class="cl"> jvm          Display the target JVM information
</span></span><span class="line"><span class="cl"> perfcounter  Display the perf counter information.
</span></span><span class="line"><span class="cl"> ognl         Execute ognl expression.
</span></span><span class="line"><span class="cl"> mc           Memory compiler, compiles java files into bytecode and class files in memory.
</span></span><span class="line"><span class="cl"> redefine     Redefine classes. @see Instrumentation#redefineClasses(ClassDefinition...)
</span></span><span class="line"><span class="cl"> dashboard    Overview of target jvm&#39;s thread, memory, gc, vm, tomcat info.
</span></span><span class="line"><span class="cl"> dump         Dump class byte array from JVM
</span></span><span class="line"><span class="cl"> heapdump     Heap dump
</span></span><span class="line"><span class="cl"> options      View and change various Arthas options
</span></span><span class="line"><span class="cl"> cls          Clear the screen
</span></span><span class="line"><span class="cl"> reset        Reset all the enhanced classes
</span></span><span class="line"><span class="cl"> version      Display Arthas version
</span></span><span class="line"><span class="cl"> session      Display current session information
</span></span><span class="line"><span class="cl"> sysprop      Display, and change the system properties.
</span></span><span class="line"><span class="cl"> sysenv       Display the system env.
</span></span><span class="line"><span class="cl"> vmoption     Display, and update the vm diagnostic options.
</span></span><span class="line"><span class="cl"> logger       Print logger info, and update the logger level
</span></span><span class="line"><span class="cl"> history      Display command history
</span></span><span class="line"><span class="cl"> cat          Concatenate and print files
</span></span><span class="line"><span class="cl"> echo         write arguments to the standard output
</span></span><span class="line"><span class="cl"> pwd          Return working directory name
</span></span><span class="line"><span class="cl"> mbean        Display the mbean information
</span></span><span class="line"><span class="cl"> grep         grep command for pipes.
</span></span><span class="line"><span class="cl"> tee          tee command for pipes.
</span></span><span class="line"><span class="cl"> profiler     Async Profiler. https://github.com/jvm-profiling-tools/async-profiler
</span></span><span class="line"><span class="cl"> stop         Stop/Shutdown Arthas server and exit the console.
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="jvm相关">jvm相关</h2>
<h3 id="dashboard">dashboard</h3>
<p>当前系统的实时数据面板。<a href="https://arthas.aliyun.com/doc/dashboard.html">dashboard官方文档</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[arthas@5301]$ dashboard
</span></span></code></pre></td></tr></table>
</div>
</div><p>每一列的说明：</p>
<ul>
<li>ID: Java 级别的线程 ID，注意这个 ID 不能跟 jstack 中的 nativeID 一一对应。</li>
<li>NAME: 线程名</li>
<li>GROUP: 线程组名</li>
<li>PRIORITY: 线程优先级, 1~10 之间的数字，越大表示优先级越高</li>
<li>STATE: 线程的状态</li>
<li>CPU%: 线程的 cpu 使用率。比如采样间隔 1000ms，某个线程的增量 cpu 时间为 100ms，则 cpu 使用率=100/1000=10%</li>
<li>DELTA_TIME: 上次采样之后线程运行增量 CPU 时间，数据格式为秒</li>
<li>TIME: 线程运行总 CPU 时间，数据格式为分:秒</li>
<li>INTERRUPTED: 线程当前的中断位状态</li>
<li>DAEMON: 是否是 daemon 线程
<ul>
<li>daemon 线程是个服务线程，准确地来说就是服务其他的线程。</li>
<li>比如垃圾回收线程，就是最典型的守护线程。</li>
</ul>
</li>
</ul>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4718ab96ea24d94905acd88b838b5b6~tplv-k3u1fbpfcp-watermark.image?" alt="arthas-dashboard.png"></p>
<h3 id="jvm">jvm</h3>
<p><code>jvm</code>可以查看当前 JVM 信息。<a href="https://arthas.aliyun.com/doc/jvm.html">jvm官方文档</a></p>
<p>实际实行效果如下（其中把部分value已删除）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[arthas@5301]$ jvm
</span></span><span class="line"><span class="cl"> RUNTIME
</span></span><span class="line"><span class="cl">-------------------------------------------------------------------------------------------------------------------------------------------------------------
</span></span><span class="line"><span class="cl"> MACHINE-NAME                                 
</span></span><span class="line"><span class="cl"> JVM-START-TIME                               
</span></span><span class="line"><span class="cl"> MANAGEMENT-SPEC-VERSION                      
</span></span><span class="line"><span class="cl"> SPEC-NAME                                    
</span></span><span class="line"><span class="cl"> SPEC-VENDOR                                  
</span></span><span class="line"><span class="cl"> SPEC-VERSION                                 
</span></span><span class="line"><span class="cl"> VM-NAME                                      
</span></span><span class="line"><span class="cl"> VM-VENDOR                                    
</span></span><span class="line"><span class="cl"> VM-VERSION                                   
</span></span><span class="line"><span class="cl"> INPUT-ARGUMENTS                              --add-opens=java.base/java.lang=ALL-UNNAMED
</span></span><span class="line"><span class="cl">                                              --add-opens=java.base/java.io=ALL-UNNAMED
</span></span><span class="line"><span class="cl">                                              --add-opens=java.rmi/sun.rmi.transport=ALL-UNNAMED
</span></span><span class="line"><span class="cl"> CLASS-PATH                                   
</span></span><span class="line"><span class="cl"> BOOT-CLASS-PATH
</span></span><span class="line"><span class="cl"> LIBRARY-PATH                                 /usr/java/packages/lib:/usr/lib64:/lib64:/lib:/usr/lib
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">-------------------------------------------------------------------------------------------------------------------------------------------------------------
</span></span><span class="line"><span class="cl"> CLASS-LOADING
</span></span><span class="line"><span class="cl">-------------------------------------------------------------------------------------------------------------------------------------------------------------
</span></span><span class="line"><span class="cl"> LOADED-CLASS-COUNT                           21745
</span></span><span class="line"><span class="cl"> TOTAL-LOADED-CLASS-COUNT                     21745
</span></span><span class="line"><span class="cl"> UNLOADED-CLASS-COUNT                         0
</span></span><span class="line"><span class="cl"> IS-VERBOSE                                   false
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">-------------------------------------------------------------------------------------------------------------------------------------------------------------
</span></span><span class="line"><span class="cl"> COMPILATION
</span></span><span class="line"><span class="cl">-------------------------------------------------------------------------------------------------------------------------------------------------------------
</span></span><span class="line"><span class="cl"> NAME                                         HotSpot 64-Bit Tiered Compilers
</span></span><span class="line"><span class="cl"> TOTAL-COMPILE-TIME                           152700
</span></span><span class="line"><span class="cl"> [time (ms)]
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">-------------------------------------------------------------------------------------------------------------------------------------------------------------
</span></span><span class="line"><span class="cl"> GARBAGE-COLLECTORS
</span></span><span class="line"><span class="cl">-------------------------------------------------------------------------------------------------------------------------------------------------------------
</span></span><span class="line"><span class="cl"> ZGC                                          name : ZGC
</span></span><span class="line"><span class="cl"> [count/time (ms)]                            collectionCount : 173
</span></span><span class="line"><span class="cl">                                              collectionTime : 2118
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">-------------------------------------------------------------------------------------------------------------------------------------------------------------
</span></span><span class="line"><span class="cl"> MEMORY-MANAGERS
</span></span><span class="line"><span class="cl">-------------------------------------------------------------------------------------------------------------------------------------------------------------
</span></span><span class="line"><span class="cl"> CodeCacheManager                             CodeHeap &#39;non-nmethods&#39;
</span></span><span class="line"><span class="cl">                                              CodeHeap &#39;profiled nmethods&#39;
</span></span><span class="line"><span class="cl">                                              CodeHeap &#39;non-profiled nmethods&#39;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> Metaspace Manager                            Metaspace
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> ZGC                                          ZHeap
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">-------------------------------------------------------------------------------------------------------------------------------------------------------------
</span></span><span class="line"><span class="cl"> MEMORY
</span></span><span class="line"><span class="cl">-------------------------------------------------------------------------------------------------------------------------------------------------------------
</span></span><span class="line"><span class="cl"> HEAP-MEMORY-USAGE                            init : 3865051136(3.6 GiB)
</span></span><span class="line"><span class="cl"> [memory in bytes]                            used : 650117120(620.0 MiB)
</span></span><span class="line"><span class="cl">                                              committed : 5024776192(4.7 GiB)
</span></span><span class="line"><span class="cl">                                              max : 6442450944(6.0 GiB)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> NO-HEAP-MEMORY-USAGE                         init : 7667712(7.3 MiB)
</span></span><span class="line"><span class="cl"> [memory in bytes]                            used : 215572512(205.6 MiB)
</span></span><span class="line"><span class="cl">                                              committed : 222756864(212.4 MiB)
</span></span><span class="line"><span class="cl">                                              max : 520093696(496.0 MiB)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> PENDING-FINALIZE-COUNT                       0
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">-------------------------------------------------------------------------------------------------------------------------------------------------------------
</span></span><span class="line"><span class="cl"> OPERATING-SYSTEM
</span></span><span class="line"><span class="cl">-------------------------------------------------------------------------------------------------------------------------------------------------------------
</span></span><span class="line"><span class="cl"> OS                                           Linux
</span></span><span class="line"><span class="cl"> ARCH                                         amd64
</span></span><span class="line"><span class="cl"> PROCESSORS-COUNT                             4
</span></span><span class="line"><span class="cl"> LOAD-AVERAGE                                 38.85
</span></span><span class="line"><span class="cl"> VERSION                                      
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">-------------------------------------------------------------------------------------------------------------------------------------------------------------
</span></span><span class="line"><span class="cl"> THREAD
</span></span><span class="line"><span class="cl">-------------------------------------------------------------------------------------------------------------------------------------------------------------
</span></span><span class="line"><span class="cl"> COUNT                                        430
</span></span><span class="line"><span class="cl"> DAEMON-COUNT                                 416
</span></span><span class="line"><span class="cl"> PEAK-COUNT                                   431
</span></span><span class="line"><span class="cl"> STARTED-COUNT                                1314
</span></span><span class="line"><span class="cl"> DEADLOCK-COUNT                               0
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">-------------------------------------------------------------------------------------------------------------------------------------------------------------
</span></span><span class="line"><span class="cl"> FILE-DESCRIPTOR
</span></span><span class="line"><span class="cl">-------------------------------------------------------------------------------------------------------------------------------------------------------------
</span></span><span class="line"><span class="cl"> MAX-FILE-DESCRIPTOR-COUNT                    -1
</span></span><span class="line"><span class="cl"> OPEN-FILE-DESCRIPTOR-COUNT                   -1
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>THREAD 相关
<ul>
<li>COUNT: JVM 当前活跃的线程数</li>
<li>DAEMON-COUNT: JVM 当前活跃的守护线程数</li>
<li>PEAK-COUNT: 从 JVM 启动开始曾经活着的最大线程数</li>
<li>STARTED-COUNT: 从 JVM 启动开始总共启动过的线程次数</li>
<li>DEADLOCK-COUNT: JVM 当前死锁的线程数</li>
</ul>
</li>
<li>文件描述符相关
<ul>
<li>MAX-FILE-DESCRIPTOR-COUNT：JVM 进程最大可以打开的文件描述符数</li>
<li>OPEN-FILE-DESCRIPTOR-COUNT：JVM 当前打开的文件描述符数</li>
</ul>
</li>
</ul>
<h3 id="thread-1">thread</h3>
<p>使用<code>thread ${ID}</code>会打印线程 ID 的栈，类似下图。<a href="https://arthas.aliyun.com/doc/thread.html">thread官方文档</a></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9cb3130b93474ea19bb8ec958e481e62~tplv-k3u1fbpfcp-watermark.image?" alt="arthas-thread.png"></p>
<h2 id="classclassloader相关">class/classloader相关</h2>
<h3 id="sc--sm">sc &amp; sm</h3>
<ul>
<li><code>sc</code> - 查看 JVM 已加载的类信息
<ul>
<li>“Search-Class” 的简写，这个命令能搜索出所有已经加载到 JVM 中的 Class 信息。</li>
</ul>
</li>
<li><code>sm</code> - 查看已加载类的方法信息。
<ul>
<li>“Search-Method” 的简写，这个命令能搜索出所有已经加载了 Class 信息的方法信息。</li>
</ul>
</li>
</ul>
<h3 id="jad">jad</h3>
<p>反编译指定已加载类的源码，可以查看部署在线上服务器的.class文件对应的java源码。该功能基于一个第三方的反编译工具CFR实现。</p>
<p>注: 可以使用reset命令对增强后的class文件还原, 或者shutdown服务端关闭时也会重置所有增强过的类。</p>
<p>jad官方文档：https://arthas.aliyun.com/doc/jad.html</p>
<h3 id="redefine">redefine</h3>
<p>加载外部的.class文件替换掉当前的类。类似于热加载或热修复的功能, 修改java文件编译后的, 将替换掉jvm已加载的.class类, 基于jdk本身的限制, 修改的class文件里不允许新增加成员变量和方法</p>
<p>基于这个功能可以模拟一个简单的监控功能, 比如在java文件的某个方法里加上调用耗时和请求参数的打印功能, 然后使用redefine即可看到该方法的耗时时间和参数值, 并且不用重启服务</p>
<p>redefine -p D:/XOrderDetailLoungeMapper.class</p>
<p>注意: 使用时需谨慎,确保修改的代码能正确编译并且逻辑正确,毕竟这个命令的杀伤力太大,验证过之后最好通过 reset 命令还原回来。</p>
<p>redefine官方文档：https://arthas.aliyun.com/doc/redefine.html</p>
<h2 id="monitorwatchtrace-相关">monitor/watch/trace 相关</h2>
<h3 id="watch">watch</h3>
<p>观察指定方法的调用情况, 包括返回值、异常、入参、对象属性值。
格式: watch 类名 方法名 [params:入参, target:当前对象, returnObj:返回值] -x 表示展开或遍历的深度，可以调整来打印具体的参数和结果内容</p>
<p>watch官方文档：https://arthas.aliyun.com/doc/watch.html</p>
<h3 id="trace">trace</h3>
<p>方法内部调用路径，并输出方法路径上的每个节点上耗时。</p>
<p>主要用于统计整个调用链路上的所有性能开销和追踪调用链路,使用下来感觉这个命令也是很有用的,包括本地环境, 尤其是要排查接口响应时间慢这样的场景下,可以快速定位到具体哪个方法或哪些方法导致的,甚至包括第三方的方法.</p>
<p>trace官方文档：https://arthas.aliyun.com/doc/trace.html</p>
<h3 id="stack">stack</h3>
<p>输出当前方法被调用的路径。</p>
<p>stack官方文档：https://arthas.aliyun.com/doc/stack.html</p>
<h3 id="tt">tt</h3>
<p>time tunnel 时间轴, 记录下指定方法每次调用的入参和返回信息。</p>
<p>tt官方文档：https://arthas.aliyun.com/doc/tt.html</p>
<h2 id="profiler火焰图">profiler/火焰图</h2>
<p><code>profiler</code>可能是arthas中使用的最多的一个命令了，arthas里的火焰图也是集成的开源项目 <a href="https://github.com/jvm-profiling-tools/async-profiler">async-profiler</a>。</p>
<p>火焰图可以直观的分析代码占用cpu, 内存, 锁争用的情况, 比较直观, 但是这个命令只支持Linux和Mac系统, 一般可以用于线上环境的诊断</p>
<p>说明: 纵轴表示栈帧深度, 横轴表示代码占用CPU/内存的比例, 点击可以查看详情。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[arthas@5301]$ profiler start
</span></span><span class="line"><span class="cl">Started [cpu] profiling
</span></span><span class="line"><span class="cl">[arthas@5301]$ profiler getSamples
</span></span><span class="line"><span class="cl">97
</span></span><span class="line"><span class="cl">[arthas@5301]$ profiler status
</span></span><span class="line"><span class="cl">[perf] profiling is running for 61 seconds
</span></span><span class="line"><span class="cl">[arthas@5301]$ profiler stop  --file /tmp/result.html
</span></span><span class="line"><span class="cl">OK
</span></span><span class="line"><span class="cl">profiler output file: /tmp/result.html
</span></span></code></pre></td></tr></table>
</div>
</div><p>以上操作是将profiler启动后，再手动停止。也可以定时生成一定时间内的火焰图。以下指令生成了开始采样后10秒内的火焰图。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">profiler start -d 10 --file /tmp/flame-graph.svg
</span></span></code></pre></td></tr></table>
</div>
</div><p>生成的文件目录</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[user@server-name tmp]$ ls -lh | grep result.html
</span></span><span class="line"><span class="cl">-rw-r----- 1 deploy deploy 122K Aug  5 11:30 result.html
</span></span></code></pre></td></tr></table>
</div>
</div><p>profiler官方文档：https://arthas.aliyun.com/doc/profiler.html</p>
<h1 id="mat">mat</h1>
<p><code>MAT</code>（全名：<code>Memory Analyzer Tool</code>），是一款快速便捷且功能强大丰富的 JVM <strong>堆内存</strong> <strong>离线</strong> 分析工具。通过展现 JVM 异常时所记录的运行时堆转储快照（Heap dump）状态（正常运行时也可以做堆转储分析），帮助定位内存泄漏问题或优化大内存消耗逻辑。</p>
<p>官网地址：https://www.eclipse.org/mat/</p>
<p>官方说明文档：https://help.eclipse.org/2020-09/index.jsp?topic=/org.eclipse.mat.ui.help/welcome.html</p>
<p>MAT 的工作原理是对 dump 文件建立多种索引，并基于索引来实现以下四大核心功能，在这些功能的基础上再通过可视化展现辅助 Developer 精细化了解 JVM 堆内存全貌。</p>
<ol>
<li>内存分布</li>
<li>对象间依赖（如实体对象引用关系、线程引用关系、ClassLoader引用关系等）</li>
<li>对象状态（内存占用量、字段属性值等）</li>
<li>条件检索（OQL、正则匹配查询等）</li>
</ol>
<h2 id="应用场景">应用场景</h2>
<ol>
<li>内存溢出，JVM堆区或方法区放不下存活及待申请的对象。
<ul>
<li>如：高峰期系统出现 OOM（Out of Memory）异常，需定位内存瓶颈点来指导优化。</li>
</ul>
</li>
<li>内存泄漏，不会再使用的对象无法被垃圾回收器回收。
<ul>
<li>如：系统运行一段时间后出现 <code>Full GC</code>，甚至周期性 <code>OOM</code> 后需人工重启解决。</li>
</ul>
</li>
<li>内存占用高。
<ul>
<li>如：系统频繁 <code>GC</code>，需定位影响服务实时性、稳定性、吞吐能力的原因。</li>
</ul>
</li>
</ol>
<h2 id="使用介绍">使用介绍</h2>
<h3 id="overview-1">Overview</h3>
<p>堆内存大小、对象个数、类的个数、类加载器的个数、GC root 个数、线程概况等全局统计信息。主要包括以下一个主要模块。</p>
<ul>
<li><code>全局概览信息</code>
<ul>
<li>堆内存大小、类数量、实例数量、Class Loader数量。</li>
</ul>
</li>
<li><code>Unreachable Object Histogram</code>
<ul>
<li>展现转储快照时可被回收的对象信息</li>
<li>一般不需要关注，除非 GC 频繁影响实时性的场景分析才用到</li>
</ul>
</li>
<li><code>Biggest Objects by Retained Size</code>
<ul>
<li>展现经过统计过的哪几个实例所关联的对象占内存总和较高，以及具体占用的内存大小，一般相关代码比较简单情况下，往往可以直接分析具体的引用关系异常，如内存泄漏等。</li>
<li>此外也包含了最大对象和链接支持继续深入分析。</li>
</ul>
</li>
</ul>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/feabca531bc94d5c99728e84fdbce0e1~tplv-k3u1fbpfcp-watermark.image?" alt="mat-overview.png"></p>
<h3 id="object-view">Object View</h3>
<p>通过mat页面左侧的 <code>inspector</code> 面板可以查看对象的属性信息、类继承关系信息等数据，协助分析内存占用高与业务逻辑的关系。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64b4cc356e58482bbd781732ec8b387e~tplv-k3u1fbpfcp-watermark.image?" alt="mat-object-view.png"></p>
<p>集合状态的检测，如：通过 ArrayList 或数组的填充率定位空集合空数组造成的内存浪费、通过 HashMap 冲突率判定 hash 策略是否合理等。</p>
<h3 id="actions">Actions</h3>
<h4 id="histogram">histogram</h4>
<p>罗列每个类实例的内存占比，包括自身内存占用量（Shallow Heap）及支配对象的内存占用量（Retain Heap），支持按 package、class loader、super class、class 聚类统计，最常用的功能之一。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e5faf1e4e4742dbb8142b2df1d069a6~tplv-k3u1fbpfcp-watermark.image?" alt="mat-histogram.png"></p>
<h4 id="dominator-tree">dominator-tree</h4>
<p>按对象的 Retain Heap 排序，也支持按多个维度聚类统计，并提供详细的支配关系，结合 references 可以实现大对象快速关联分析，最常用的功能之一。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/215acb20f19346028c362794c6662dde~tplv-k3u1fbpfcp-watermark.image?" alt="mat-dominator-tree.png"></p>
<h4 id="top-consumer">top-consumer</h4>
<p>展现哪些类、哪些 class loader、哪些 package 占用最高比例的内存。
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff763119d7c345c4aee77d62c7faa71f~tplv-k3u1fbpfcp-watermark.image?" alt="mat-top-consumer.png"></p>
<h4 id="duplicate-classes">duplicate-classes</h4>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef7da3bb1a7a47f18e32f283186b5089~tplv-k3u1fbpfcp-watermark.image?" alt="mat-duplicate-classes.png"></p>
<h3 id="reports">Reports</h3>
<h4 id="leak-suspects">leak-suspects</h4>
<p>直击引用链条上占用内存较多的可疑对象，可解决一些基础问题，但复杂的问题往往帮助有限。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c14a528fe89a4ae58f809f81d1065509~tplv-k3u1fbpfcp-watermark.image?" alt="mat-leak-suspects.png"></p>
<h4 id="top-components">top-components</h4>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a850f5672f7404e8300f12b320b0f77~tplv-k3u1fbpfcp-watermark.image?" alt="mat-top-components.png"></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/865acc50203641e9ad59cc76fbfa9a58~tplv-k3u1fbpfcp-watermark.image?" alt="mat-top-components-2.png"></p>
<h2 id="使用技巧">使用技巧</h2>
<h3 id="索引构建">索引构建</h3>
<p>mat很多时候启动会很慢，慢的原因就是mat为提升检索速率，需要在初始化时构建索引<code>index</code>文件。这一点当dump文件特别大的时候尤其明显，所以建议如果有可能的话，一开始可以将dump文件放在一台内存和CPU都相对较高的机器上完成初始化的索引构建，再将类似下图的文件全部拷贝到用于分析的机器上。这样可以大大提升分析效率。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93a0ba64861045eba1c8a0240f13f474~tplv-k3u1fbpfcp-watermark.image?" alt="mat-index-file.png"></p>
<h3 id="条件搜索">条件搜索</h3>
<p>如下图，可以在搜索框中输入需要查找的类名或关键字，内存分布及对象间依赖的众多功能，均支持按字符串检索、按正则检索等操作。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e46e24aeb91d4d52a2869f244bb9f877~tplv-k3u1fbpfcp-watermark.image?" alt="mat-search.png"></p>
<p>除以上输入框的搜索外，mat还支持<code>OQL</code>、<code>虚拟内存地址寻址</code>。</p>
<ul>
<li>OQL，提供一种类似于SQL的对象（类）级别统一结构化查询语言。
<ul>
<li>查找 size＝0 且未使用过的 ArrayList。
<ul>
<li><code>select * from java.util.ArrayList where size=0 and modCount=0</code>；</li>
</ul>
</li>
<li>查找所有的String的length属性的
<ul>
<li><code>select s.length from instanceof String s</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4ab7aeb0f534cb68b9688c62c7e60b8~tplv-k3u1fbpfcp-watermark.image?" alt="mat-oql-1.png"></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/535a6d33ddad426cbcf9130bd317702a~tplv-k3u1fbpfcp-watermark.image?" alt="mat-oql-2.png"></p>
<ul>
<li>虚拟内存地址寻址
<ul>
<li>根据对象的十六进制地址查找对象
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/104067c4b65f45a2bde888e662bcaf23~tplv-k3u1fbpfcp-watermark.image?" alt="mat-hex.png"></li>
</ul>
</li>
</ul>
<h3 id="references">References</h3>
<p>提供对象的外部引用关系、被引用关系。通过任一对象的直接引用及间接引用详情（主要是属性值及内存占用），进而提供完善的依赖链路详情。通过<code>outgoing references</code>、<code>incoming references</code> 可以直击对象间依赖关系，MAT 也提供了链式快速操作。</p>
<ul>
<li>
<p><code>outgoing references</code></p>
<ul>
<li>对象引用的外部对象（注意不包含对象的基本类型属性。基本属性内容可在 inspector 查看）。</li>
</ul>
</li>
<li>
<p><code>incoming references</code></p>
<ul>
<li>直接引用了当前对象的对象，每个对象的 incoming references 可能有 0 到多个。</li>
</ul>
</li>
<li>
<p>外部引用关系：</p>
<ul>
<li>with outgoing references</li>
<li>with incoming references
<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f53a667fbc9e4100b7fb8a14db04ff60~tplv-k3u1fbpfcp-watermark.image?" alt="mat-list-object.png"></li>
</ul>
</li>
<li>
<p>被引用关系：</p>
<ul>
<li>by outgoing references</li>
<li>by incoming references
<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5cf9d668f3e4111a12a80eda3e89d94~tplv-k3u1fbpfcp-watermark.image?" alt="mat-show-objects-by-class.png"></li>
</ul>
</li>
</ul>
<h3 id="path-to-gc-roots">Path To GC Roots</h3>
<p><code>Path To GC Roots</code>：提供任一对象到GC Root的链路详情，帮助了解不能被 GC 回收的原因。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00abdeeff5e745949594006c3fee82a9~tplv-k3u1fbpfcp-watermark.image?" alt="mat-merge-shortest-paths-to-gc-roots.png"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/863d99658fe0419c8a0bcc717318389d~tplv-k3u1fbpfcp-watermark.image?" alt="mat-java-basics.png"></p>
<p><code>GC Root</code>：GC Root 代表通过可达性分析来判定 JVM 对象是否存活的起始集合。JVM 采用追踪式垃圾回收（Tracing GC）模式，从所有 GC Roots 出发通过引用关系可以关联的对象就是存活的（且不可回收），其余的不可达的对象（Unreachable object：如果无法从 GC Root 找到一条引用路径能到达某对象，则该对象为Unreachable object）可以回收。</p>
<h1 id="jprofiler">JProfiler</h1>
<p><code>JProfiler</code>是一款同时支持离线和在线的性能分析工具，需要注意<code>JProfiler</code>是收费的应用，需要激活。这里简单介绍下相关的使用情况。</p>
<p>打开hprof文件，进入classes视图，可以查看instance Count和Size等基本信息，大部分情况下占用多的都是<code>byte[]</code>或<code>long[]</code>等，需要根据具体的业务分析具体对应的class。
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1a6bdf7b9114e97a50a6366c5086be8~tplv-k3u1fbpfcp-watermark.image?" alt="jprofiler-classes.png"></p>
<p><code>allocations</code>视图可以查看具体的分配情况，但是本次dump的格式为<code>.hprof</code>，<code>JProfiler</code>不支持读取。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc79a194f3d4489ea780ccd4c1f867a0~tplv-k3u1fbpfcp-watermark.image?" alt="jprofiler-allocations.png"></p>
<p>在<code>biggest-objects</code>视图中可以查看当前堆中较大的对象。
<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1933464c7638438b82c606839a2a27b8~tplv-k3u1fbpfcp-watermark.image?" alt="jprofiler-biggest-objects.png"></p>
<p>选中需要分析的大对象后，可以右击选中<code>show in graph</code>。
<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e916c41b45a4bf09ba8a14388f1bdc3~tplv-k3u1fbpfcp-watermark.image?" alt="jprofiler-show-in-graph.png"></p>
<p>在<code>graph</code>视图中可以查看类之间的应用关系。
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8de362aca11349559b3383f57b1ec666~tplv-k3u1fbpfcp-watermark.image?" alt="jprofiler-graph.png"></p>
<p>在<code>thread dump</code>视图中可以查看具体的线程堆。
<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20f6fe824fd14f04a1f2573a16f3de1e~tplv-k3u1fbpfcp-watermark.image?" alt="jprofiler-thread-dump.png"></p>
<p>先前介绍的<code>jmc</code>、<code>visualVM</code>、<code>arthas</code>等基本已经包含了<code>JProfiler</code>的大部分功能，且不收费，因此对于<code>JProfiler</code>只是简单介绍下，就不再做更深入的分析。有兴趣的同学，可以自己尝试使用下。</p>
<h1 id="native-memory-analysis">Native memory analysis</h1>
<p>本小节介绍下关于堆外内存的一些分析工具。有一点可以明确，堆外内存是由操作系统负责维护和分配的，这也就是为什么下文中会涉及到部分Linux等操作系统的命令。</p>
<h2 id="pmap">pmap</h2>
<p>使用<code>pmap</code>可以查看进程内存信息。<code>pmap</code>是<code>report memory map of a process</code>的缩写，也就是查看进程的内存映像信息。</p>
<p><code>pmap</code>命令用于报告进程的内存映射关系，是Linux调试及运维一个很好的工具。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">pmap -x pid 如果需要排序  | sort -n -k3**
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="gperftools">gperftools</h2>
<p><code>gperftools</code>是由<code>google</code>出品的一个性能分析工具。官网地址：https://github.com/gperftools/gperftools</p>
<blockquote>
<p>我们见过的最快的malloc；尤其适用于线程和 STL。另外：线程友好的堆检查器、堆分析器和 cpu 分析器。
<code>gperftools</code> 是一个高性能多线程 <code>malloc()</code> 实现的集合，以及一些非常漂亮的性能分析工具。<code>gperftools</code> 是根据 BSD 许可证的条款分发的。</p>
</blockquote>
<ol>
<li>install gcc</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">sudo yum -y install gcc make
</span></span><span class="line"><span class="cl">sudo yum -y install gcc gcc-c++
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>install libunwind</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">wget http://download.savannah.gnu.org/releases/libunwind/libunwind-0.99-beta.tar.gz
</span></span><span class="line"><span class="cl">./configure  --prefix=/data0/java/deploy/google-perftools/local/libunwind
</span></span><span class="line"><span class="cl">make
</span></span><span class="line"><span class="cl">make install
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>install gperftools</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">wget https://github.com/gperftools/gperftools/releases/download/gperftools-2.5/gperftools-2.5.tar.gz
</span></span><span class="line"><span class="cl">./confighre --prefix=/data0/java/deploy/google-perftools/local/gperftools-2.5/
</span></span><span class="line"><span class="cl">make
</span></span><span class="line"><span class="cl">make install
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="4">
<li>modify setting</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">vi /etc/ld.so.conf.d/usr_local_lib.conf
</span></span><span class="line"><span class="cl">local/gperftools-2.5/bin/pprof --text /usr/local/java/jdk1.7.0_55/bin/java test.0132.heap
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="5">
<li>dump profile</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">gcc [...] -o myprogram -ltcmalloc
</span></span><span class="line"><span class="cl">HEAPPROFILE=/tmp/netheap ./myprogram
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="6">
<li>Cpu Profiler:</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">gcc [...] -o myprogram -lprofiler
</span></span><span class="line"><span class="cl">CPUPROFILE=/tmp/profile ./myprogram
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="gdb">gdb</h2>
<p><code>pmap</code>找到内存申请的地址块，可以使用<code>gdb attach</code>后<code>dump</code>某一段的内存地址，后查看内存的数据。</p>
<p><strong>注意:</strong> <code>gdb attach</code> 进程会暂停，线上谨慎操作。</p>
<ol>
<li>安装gdb
<ul>
<li><code>sudo yum install -y gdb</code></li>
</ul>
</li>
<li>attach
<ul>
<li><code>sudo -u deploy gdb --pid={pid}</code></li>
</ul>
</li>
<li>dump内存
<ul>
<li><code>dump memory {path} {start_address} {end_address}</code></li>
<li>内存地址可以使用pmap或less /proc/{pid}/maps查看</li>
</ul>
</li>
<li>查看内存中的字面量:
<ul>
<li><code>strings {path}</code></li>
</ul>
</li>
</ol>
<h2 id="nmt">NMT</h2>
<p><code>Native Memory Tracking (NMT)</code> 堆外内存跟踪，是Hotspot VM用来分析VM内部内存使用情况的一个功能。我们可以利用上文提到的<code>jcmd</code>工具来访问NMT的数据。官方文档：https://docs.oracle.com/javase/8/docs/technotes/guides/vm/nmt-8.html</p>
<p><code>NMT</code>必须先通过VM启动参数<code>-XX:NativeMemoryTracking</code>打开，<strong>打开NMT会带来5%-10%的性能损耗</strong>。还有点需要注意，<code>NMT</code>能够分析JVM自身分配的一些内存，但是无法追踪非JVM分配的内存，例如JNI等native code，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">-XX:NativeMemoryTracking=[off | summary | detail]
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>off
<ul>
<li>默认关闭</li>
</ul>
</li>
<li>summary
<ul>
<li>只统计各个分类的内存使用情况.</li>
</ul>
</li>
<li>detail
<ul>
<li>Collect memory usage by individual call sites.</li>
</ul>
</li>
</ul>
<p>开启NMT后，运行进程，可以使用下面的<code>jcmd</code>命令查看直接内存：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">jcmd &lt;pid&gt; VM.native_memory [summary | detail | baseline | summary.diff | detail.diff | shutdown] [scale= KB | MB | GB]
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>summary
<ul>
<li>分类内存使用情况.</li>
</ul>
</li>
<li>detail
<ul>
<li>详细内存使用情况，除了summary信息之外还包含了虚拟内存使用情况。</li>
</ul>
</li>
<li>baseline
<ul>
<li>创建内存使用快照，方便和后面做对比</li>
</ul>
</li>
<li>summary.diff
<ul>
<li>和上一次baseline的summary对比</li>
</ul>
</li>
<li>detail.diff
<ul>
<li>和上一次baseline的detail对比</li>
</ul>
</li>
<li>shutdown
<ul>
<li>关闭NMT</li>
</ul>
</li>
</ul>
<h1 id="总结">总结</h1>
<p>本文所阐述的是实际开发中经常会使用到的一些Java性能监控与排障处理工具，可能在不远的将来会有更加优秀的分析工具面世。</p>
<p>但是，无论用什么工具，最终一定会定位到具体的业务代码或者框架的代码，再加上对于业务和技术的理解相互配合才能准确的定位到问题，单单为了使用工具而来学习工具，这样做的意义不大。</p>
<p>只有多多分析问题，排查问题才能对发挥出各种工具应有的价值。</p>
<p>重要的事情说三遍：<strong>实践</strong>、<strong>实践</strong>、<strong>实践</strong>。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b55e133ac64434fb57238a85c196a33~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<h1 id="参考文献">参考文献</h1>
<ul>
<li><a href="https://www.jianshu.com/p/9baea772cb21">JVM——jmc使用说明</a></li>
<li><a href="https://juejin.cn/post/6908665391136899079">JVM 内存分析工具 MAT 的深度讲解与实践——入门篇</a></li>
<li><a href="https://segmentfault.com/a/1190000017795841">性能诊断利器 JProfiler 快速入门和最佳实践</a></li>
<li><a href="https://developer.aliyun.com/article/276">深入浅出JProfiler</a></li>
<li><a href="https://www.ej-technologies.com/resources/jprofiler/help/doc/main/introduction.html">Introduction To JProfiler</a></li>
<li><a href="https://mahaijin.github.io/2015/04/27/JVM%E7%9A%84Heap%20Memory%E5%92%8CNative%20Memory/">【原创】JVM的Heap Memory和Native Memory</a></li>
<li><a href="https://stackoverflow.com/questions/30622818/what-is-the-difference-between-off-heap-native-heap-direct-memory-and-native-m">What is the difference between off-heap, native heap, direct memory and native memory?</a></li>
<li><a href="https://heapdump.cn/article/1821465">一次完整的JVM堆外内存泄漏故障排查记录</a></li>
<li><a href="http://static.kancloud.cn/zhangchio/springboot/806316">Java 内存之直接内存（堆外内存）</a></li>
<li><a href="https://heapdump.cn/article/1778047">记一次JVM堆外内存泄露Bug的查找</a></li>
<li><a href="https://heapdump.cn/article/150614">JVM源码分析之堆外内存完全解读</a></li>
<li><a href="http://www.dylan326.com/2017/09/28/gperftools/">gperftools做堆外内存分析（案例JVM Inflater 内存泄漏分析）</a></li>
<li><a href="https://www.oracle.com/java/technologies/javase/memleaks.html">Troubleshooting Guide for Java SE 6 with HotSpot VM</a></li>
<li><a href="https://www.jianshu.com/p/309c9f61d495">google-perftools安装</a></li>
<li><a href="https://gperftools.github.io/gperftools/cpuprofile.html">gperftools CPU profiler</a></li>
<li><a href="https://tech.meituan.com/2019/01/03/spring-boot-native-memory-leak.html">Spring Boot引起的“堆外内存泄漏”排查及经验总结</a></li>
</ul>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">空歌白石</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2022-08-06
        
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://en.wikipedia.org/wiki/Wikipedia:Text_of_Creative_Commons_Attribution-ShareAlike_3.0_Unported_License" target="_blank">Creative Commons Attribution-ShareAlike License</a></span>
  </p>
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a>
          <a href="/tags/jvm/">JVM</a>
          <a href="/tags/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/">性能分析</a>
          </div>
      <nav class="post-nav">
        
        <a class="next" href="/post/netty%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">
            <span class="next-text nav-default">Netty源码剖析学习笔记</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:liubr1491@163.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/liubr1491" class="iconfont icon-github" title="github"></a>
      <a href="https://weibo.com/u/2631831764" class="iconfont icon-weibo" title="weibo"></a>
      <a href="https://www.zhihu.com/people/maybe1491" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://www.douban.com/people/196351890" class="iconfont icon-douban" title="douban"></a>
      <a href="https://space.bilibili.com/473428902" class="iconfont icon-bilibili" title="bilibili"></a>
      <a href="https://juejin.cn/user/1310273590294168" class="iconfont icon-link" title="link"></a>
  <a href="https://liubr1491.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2020 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span>空歌白石</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.64437849d125a2d603b3e71d6de5225d641a32d17168a58106e0b61852079683.js"></script>








</body>
</html>
